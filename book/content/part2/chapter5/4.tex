这个错误影响了效率和可读性。开发人员多年来一直在使用 C FILE 对象，但它通常比预想的更复杂。

\mySamllsection{问题}

开发人员经常需要打开文件并读取文本行，而 C FILE 对象已在 C++ 代码中广泛用于此目的。以下清单中的代码显示了一种常见方法，即尝试打开文件；测试此假设是否准确；如果正确，则继续逐行读取文件。

\filename{清单5.7 使用FILE读取文本行}

\begin{cpp}
const int SIZE = 100; // 1
int main() {
  FILE* file;
  file = fopen("data.txt", "r");
  if (!file) { // 2
    std::cerr << "Error opening file\n";
    return 1;
  }
  char buffer[SIZE];
  while (!feof(file)) {
    if (!fgets(buffer, SIZE, file)) // 3
      break;
    std::cout << buffer;
  }
  return 0;
}
\end{cpp}

{\footnotesize
注释1：希望每行不超过 99 个字符

注释2：首次使用负逻辑

注释3：负逻辑，希望读完整行
}

\mySamllsection{分析}

清单 5.7 中的代码运行良好，实现了编写它的目的。但它清楚吗？代码在三个地方使用了负逻辑：测试是否成功打开文件、测试行尾条件以及测试是否已读取行。负逻辑总是比正逻辑更耗费认知。当负逻辑嵌套时，负载会增加，如本例所示。此外，编写负逻辑更加困难。看似自然的方法必须被反转，并且结果流必须保存在短期记忆中。

代码的另一个问题是行长。代码假设每行的长度不会超过 99 个字符。这个假设合理吗？无论使用什么值，都存在这样的可能：要么太小，导致每行读取多次；要么太大，导致内存使用效率低下。

虽然从技术上来说这不是错误，但缓冲区定义应该大一个字符以预测行尾字符。假设一行文本恰好是 SIZE 个字符，则将在循环的下一次迭代中读取行尾字符。这种方法对性能有轻微影响，因为每行都应该进行一次读取操作。尽管如此，SIZE 没有好的定义；只存在可行的定义。

最后，FILE 对象保持打开状态。长期运行的程序如果存在此错误，可能会对系统资源产生负面影响，并可能导致资源耗尽。

\mySamllsection{解决}

这些问题可以使用 C++ std::ifstream 对象来解决。清单 5.8 中没有负逻辑，因此更容易编写和阅读。缺乏负逻辑意味着代码读起来很简单。如果未打开输入文件，则失败测试读起来很自然。

此解决方案没有缓冲区；而是使用 std::string 对象。每行输入所需的大小都是 line 变量的长度。此外，在创建每行时，字符串中不 存在先前的数据。执行部分读取时，缓冲区总是容易受到额外数据的影响。

std::ifstream 对象在 main 函数结束时超出范围。这一事实确保文件将被关闭。这是 RAII 模式的一个极好示例，其中构造函数-析构函数对管理动态资源。关闭流是可以的，但没有必要。这种方法简化了 写入和读取。开发人员必须确保记录自动销毁；否则，他们只能猜测会发生什么。标准模板库在这方面非常出色。

\filename{清单5.8 使用ifstream读取文本行}

\begin{cpp}
int main() {
  std::ifstream file("data.txt");
  if (file.fail()) { // 1
    std::cerr << "Error opening file\n";
    return 1;
  }
  std::string line;
  while (std::getline(file, line)) // 2
  std::cout << line << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：积极逻辑使阅读和写作更容易

注释2：更积极的逻辑，不覆盖旧数据
}

std::ifstream 方法是一种读取文本数据并测试流中是否存在影响其操作的错误的简单方法。此方法优于从 C 继承的 FILE* 方法。

\mySamllsection{建议}

\begin{itemize}
\item
使用 std::ifstream 和 std::ofstream 对象简化文件数据的读取和写入。

\item
尽可能使用正逻辑。
\end{itemize}


































