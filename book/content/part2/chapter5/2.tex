这种错误会影响正确性、可读性、有效性，有时还会影响性能。宏是一种向程序源代码添加信息，而不直接由编译器检查的方法。编译受影响的源代码时会，检查宏的文本，所以某些错误可能不明显、难以调试。

\mySamllsection{问题}

清单 5.3 中引入了 C++ 宏。通常，宏旨在通过赋予文字值一个有意义的名称来定义文字值，该名称记录了它们在程序中的用途。

另一个用途是生成函数式结构，来记录它们的使用。与大多数函数一样，可能需要参数，宏也可以很好地处理参数。

此外，宏可以通过在一个符号中，定义大量重复代码来减少编码工作量。以下代码尝试通过在一个符号中指定初始化、延续和更新部分，最大限度地减少编写 for 循环所需的工作量。有了所有这些(明显的)优势，建议少使用它们(如果有的话)似乎有些危言耸听。

\filename{清单5.3 使用宏定义、减少和添加类型}

\begin{cpp}
#define PI 3.1415927 // 1
#define SQUARE(n) n * n // 2
#define FOR(a, b) for (i = a; i < b; ++i); // 3
#define FALSE 0 // 4
#define TRUE !FALSE

int main() {
  int n = 3;
  std::cout << SQUARE(n) << '\n';
  std::cout << SQUARE(n + (n - 1)) << '\n';
  std::cout << SQUARE(++n) << '\n';

  int i;
  FOR(0, 10)
    std::cout << i << '\n';

  int truth = FALSE;
  ++truth; // 5
  ++truth;

  if (truth == FALSE)
    std::cout << "smooth\n";
  else
    std::cout << "dismay\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：引入没有特定类型的文字值

注释2：类似函数的构造，便于计算

注释3：通过定义结构来减少编码工作量，但其中有一个错误

注释4：另一个无类型值

注释5：开发人员正在尝试转换truth的值
}

\mySamllsection{分析}

宏最明显的问题是，在编译之前就会替换到代码中；预处理器在找到宏的地方进行文本替换，并在该位置插入文字宏定义。如果宏中出现错误，编译器可能会在稍后发现它，并报出一些与源代码不太相关的信息，编译的内容与编写的内容不同。这种情况在调试过程中会造成一些困难。

清单 5.3 中的代码存在几个与宏使用相关的问题。首先，PI 没有特定类型，通常会默认为 double；但有时，这是错误的，编译器可能会错误地确定其含义。

其次，SQUARE 宏看起来不错，但其中潜伏着危险。第一次调用平方后，结果正确。第二次调用失败，因为在宏扩展中，调用中的代码替换了两次。应该是 5 × 5 ，但变成了 3 + 2 × 3 + 2。第三次调用的结果为表达式 ++n * ++n，其中 n 为平方后的 5。

第三，FOR 宏有错误。for 循环头以分号结尾，所以没有循环体(实际上，它有一个空循环体)。因此，宏后面的代码是独立的，只执行一次，而不是预期的 10 次。另外，请注意，循环控制变量必须在 FOR 宏之前定义；这一点必须清楚，以免造成误解。

第四，尝试定义布尔数据类型只打算使用TRUE 和 FALSE 的值，这没问题，但开发人员希望对其进行类型转换。遗憾的是，由于 int 数据类型表示布尔值，所以递增会将值加 1。预期行为和实际行为不匹配，使用宏会欺骗大脑“看到”布尔约束，而编译器却完全不知道这些约束。

\mySamllsection{解决}

这些错误可以使用 C++ 语言功能解决，确保编译器参与每一步并在使用错误时发出错误。PI 的文字值定义为双精度值。这种类型在大多数情况下可能是正确的，但开发人员必须进行确认。如果编译器发现不匹配将报错，开发人员需要重新评估他们的假设。现代 C++ 提供了 constexpr 形式，这可以缓解任何此类问题。这些表达式在编译期间进行计算，并保证是正确的类型。

其次，可以创建一个名为 square 的新函数。由于不确定需要什么数据类型，因此将其构建为模板。编译器将推断出正确的参数类型，并将该类型替换为参数和返回类型。这种方法可确保使用正确的代码，而无需进行可能影响精度和性能的隐式类型转换。

第三，删除了 FOR 宏，改用 for 循环。该宏并没有减少太多代码量，但却为循环控制变量引入了一个奇怪的作用域。在循环头中定义循环控制变量，可以将其作用域控制在循环内，从而提供更好的可读性和正确性。

第四，用 C++ 提供的true值类型 bool 替换奇怪的布尔值。检测到切换变量的错误，并发出错误，要求开发人员解决错误。必须根据定义使用该类型，并且假设必须与行为相匹配。

\filename{清单5.4 使用C++结构代替宏的用法}

\begin{cpp}
const double PI = 3.1415927; // 1
template <typename T> // 2
T square(T n) {
  return n * n;
}
int main() {
  int n = 3;
  std::cout << square(n) << '\n';
  std::cout << square(n + (n - 1)) << '\n'; // 3
  std::cout << square(++n) << '\n';

  for( int i = 0; i < 10; ++ i) // 4
    std::cout << i << '\n';

  bool truth = false;
  truth = !truth; // 5
  truth = !truth;

  if (truth == false)
    std::cout << "smooth\n";
  else
    std::cout << "dismay\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：使用命名常量可以很好地记录

注释2：模板允许推断参数和返回类型

注释3：参数表达式在调用之前进行计算

注释4：变量的作用域仅限于循环

注释5：布尔值的切换(仅限于数据类型)
}

这些问题足以表明宏的危害大于帮助。互联网上有很多帖子认为在 C++ 中可以使用宏，在有限的范围内，这个建议当然正确。

我唯一同意使用宏通常合适的地方是，那些已经存在的(不幸的)具有条件编译要求的代码库。这种情况下，应删除一个条件部分和另一个条件部分之间不同的代码，并将其放入头文件中的函数中。然后，使用条件编译在函数之间进行选择。

\mySamllsection{建议}

\begin{itemize}
\item
限制或消除宏以保证安全，并生成可预测的代码。

\item
使用提供宏预期好处的 C++ 功能；编译器可以对其进行错误检查，并发出有意义的消息。
\end{itemize}













