这种错误会影响正确性、可读性、有效性，有时还会影响性能。宏是一种向程序源代码添加信息而不直接由编译器检查的方法。编译受影响的源代码时会检查宏的文本。这意味着某些错误可能不明显、难以调试，最糟糕的是，除了在最关键的情况下，宏几乎总是有效。

\mySamllsection{问题}

清单 5.3 中的代码引入了 C++ 宏的一些困难 — 还有更多困难。通常，宏旨在通过赋予文字值一个有意义的名称来定义文字值，该名称记录了它们在程序中的用途。

另一个用途是生成函数式结构来记录它们的使用。与大多数函数一样，可能需要参数。宏可以很好地处理参数，因此使用它们很诱人。

此外，宏可以通过在一个符号中定义大量重复代码来减少编码工作量 。以下代码尝试通过在一个符号中指定初始化、延续和更新部分来最大限度地减少编写 for 循环所需的工作量。有了所有这些（明显的）优势，建议很少使用它们（如果有的话）似乎有些危言耸听。

\filename{清单5.3 使用宏定义、减少和添加类型}

\begin{cpp}
#define PI 3.1415927 // 1
#define SQUARE(n) n * n // 2
#define FOR(a, b) for (i = a; i < b; ++i); ❸
#define FALSE 0 ❹
#define TRUE !FALSE

int main() {
  int n = 3;
  std::cout << SQUARE(n) << '\n';
  std::cout << SQUARE(n + (n - 1)) << '\n';
  std::cout << SQUARE(++n) << '\n';

  int i;
  FOR(0, 10)
    std::cout << i << '\n';

  int truth = FALSE;
  ++truth; // 5
  ++truth;

  if (truth == FALSE)
    std::cout << "smooth\n";
  else
    std::cout << "dismay\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：引入没有特定类型的文字值

注释2：类似函数的构造，便于计算

注释3：通过定义大部分结构来减少编码工作量，但有一个错误

注释4：另一个无类型值

注释5：开发人员正在尝试切换真值
}

\mySamllsection{分析}

宏最明显的问题是，它们在编译之前就被替换到代码中；预处理器在找到宏的地方进行文本替换，并在该位置插入文字宏定义。如果宏中出现错误，编译器可能会在稍后发现它并发出一些与源代码不太相关的古怪消息。编译的内容与编写的内容不同。这种情况在调试过程中会造成一些困难。

清单 5.3 中的代码存在几个与宏使用相关的问题。首先，PI 没有特定类型。它通常会默认为 double，这可能是正确的；然而，在极少数情况下，这可能被证明是错误的，编译器可能会错误地确定其含义。

其次，SQUARE 宏看起来不错，但其中潜伏着危险。第一次调用平方后，结果正确。第二次调用失败，因为在宏扩展中，调用中的代码被替换了两次。应该是 5 × 5 的东西变成了 3 + 2 × 3 + 2，因为调用表达式不是计算结果只是替换。第三次调用的结果为表达式 ++n * ++n，其中 n 为平方后的 5。

第三，FOR 宏有错误。for 循环头以分号结尾，这意味着没有循环体（实际上，它有一个空循环体）。因此，宏后面的代码是独立的，只执行一次，而不是预期的 10 次。另外，请注意，循环控制变量必须在 FOR 宏之前定义；这一点必须清楚，以免造成误解。

第四，尝试定义布尔数据类型在一定程度上是可行的；它只打算使用TRUE 和 FALSE 的值，开发人员演示了在它们之间切换的期望。遗憾的是，由于 int 数据类型表示布尔值，因此递增会将值加 1；它不会切换。预期行为和实际行为不匹配。使用宏会欺骗大脑“看到”布尔约束，而编译器却完全不知道任何约束。

\mySamllsection{解决}

这些错误是使用 C++ 语言功能解决的，这确保编译器参与每一步并在使用错误时发出错误。PI 的文字值定义为双精度值。这种类型在大多数情况下可能是正确的，但开发人员必须确认。如果编译器发现不匹配，它将发出错误，开发人员可以重新评估他们的假设。现代 C++ 为我们提供了 constexpr 形式，这可以缓解任何此类问题。
这些表达式在编译期间进行评估，并保证是正确的类型。

其次，创建一个名为 square 的新函数。由于不确定需要什么数据类型，因此将其构建为模板。编译器将推断出正确的参数类型，并将该类型替换为参数和返回类型。这种方法可确保使用正确的代码，而无需进行可能影响精度和性能的隐式类型转换。

第三，删除了 FOR 宏，改用 for 循环。该宏并没有减少太多代码量 ，但却为循环控制变量引入了一个奇怪的作用域。在循环头中定义循环控制变量可以将其作用域控制在循环内，从而提供更好的可读性和正确性。

第四，用 C++ 提供的真值类型 bool 替换奇怪的布尔值。检测到切换变量的错误，并发出错误，要求开发人员解决错误。必须根据定义使用该类型，并且假设必须与行为相匹配。

\filename{清单5.4 使用C++结构代替宏的用法}

\begin{cpp}
const double PI = 3.1415927; // 1
template <typename T> // 2
T square(T n) {
  return n * n;
}
int main() {
  int n = 3;
  std::cout << square(n) << '\n';
  std::cout << square(n + (n - 1)) << '\n'; // 3
  std::cout << square(++n) << '\n';

  for( int i = 0; i < 10; ++ i) // 4
    std::cout << i << '\n';

  bool truth = false;
  truth = !truth; // 5
  truth = !truth;

  if (truth == false)
    std::cout << "smooth\n";
  else
    std::cout << "dismay\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：使用命名常量可以很好地记录代码

注释2：模板允许推断参数和返回类型

注释3：参数表达式在调用之前进行求值

注释4：变量的作用域仅限于循环

注释5：真值的切换仅限于数据类型
}

还有其他几个问题可以证明，但这些问题足以表明宏的危害大于帮助。互联网上有很多帖子认为在 C++ 中使用宏是可以的，在有限的范围内，这个建议是正确的。然而，实际上，宏不应被视为普遍安全的，而应被视为在 有时 中使用是安全的。

我唯一同意使用宏通常合适的地方是那些已经存在的（不幸的）具有条件编译要求的代码库。在这种情况下，应删除一个条件部分和另一个条件部分之间不同的代码，并将其放入头文件中的函数中。然后，使用条件编译在函数之间进行选择。

\mySamllsection{建议}

\begin{itemize}
\item
限制或消除宏以保证安全并生成可预测的代码。

\item
使用提供宏预期好处的 C++ 功能；编译器可以对其进行错误检查并发出有意义的消息。
\end{itemize}













