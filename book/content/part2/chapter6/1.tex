这个错误主要关注有效性，其次是可读性。当只有 scanf 和 printf 类型的函数时，必须使用它们。然而，它们经常很难正确使用，而且读起来总是很尴尬。

\mySamllsection{问题}

许多问题需要从键盘或文件输入文本数据并将其转换为各种数据类型。scanf 和 printf 函数使用格式说明符来确定数据类型。此说明符通常是一个字符，以符号形式表示数据类型。如果使用了错误的说明符，则会导致未定义的行为。在某些情况下，错误是可以容忍的；在其他情况下，会发生崩溃，甚至更糟。如果错误的说明符不 会导致崩溃，则数据很可能是错误的。

只有当开发人员了解格式说明符的可能性时，才有可能读取格式说明符。清单 6.1 对 sscanf（字符串扫描）函数使用了复杂的格式说明符。有时，该说明符比正则表达式更难读，读者必须停下来，在脑海中解析各个部分。如果任何说明符不为人知，开发人员必须通过搜索互联网或其他资源来了解其含义和正确用法。编程的许多方面都是如此，而不仅仅是格式说明符。关键是，任何让我们停下阅读并进行一些研究的事情都是改进的机会。格式说明符就是这样一个机会。

\filename{清单6.1 使用复杂的格式说明符确定转换}

\begin{cpp}
int main() {
  const char* str = "3.14159 042 boxes .3";
  double pi;
  int cats;
  int mice;
  char buffer[5];

  int count = sscanf(str, "%lf%*c%i%s%d", &pi, &cats,
    buffer, &mice); // 1
  if (count != 4) // 2
    std::cout << "error reading value " << count+1 << '\n';

  printf("%f being eaten by %d cats in %s along with %d mice\n",
    pi, cats, mice, mice); // 3
  return 0;
}
\end{cpp}

{\footnotesize
注释1：所有输入规范都在一次操作中应用；它们正确吗？

注释2：程序员必须确定正确的数字

注释3：文本、规范和变量混合在一起很尴尬——它包含一个错误
}

\mySamllsection{分析}

格式说明符有一些不明显的奇怪之处。double 变量直观上可以使用 d 字符进行扫描和转换，但这样做会导致错误。此处的 d 字符指的是decimal，而不是 double。f 字符表示浮点值，直观上是 float 数据类型。要将文本读入 double 变量，需要使用 long 浮点说明符 lf。我们可能希望得到更直接的东西。

另一个奇怪的是，第一个整数变量使用 i 说明符（表示整数？），而第二个整数变量使用 d 说明符。第一个整数变量的输出结果是 34，而不是 42。

只要理解了 d 表示以 10 为基数的整数，谜团就解开了。相比之下，i 表示一个整数，其基数由数据的前导输入字符决定（0 表示八进制，0 x 表示十六进制，否则为十进制）。在这种情况下，前导零表示文本是八进制值。正如您所想象的，这些细节很容易被忘记。

最后，buffer 变量表示 C 样式字符串并使用 s 说明符 — 终于，一个具有直观含义的说明符了！由于开发人员知道容器是五个字符，因此为数组分配了该数量的元素。很好，很干净，但又错了。scanf 类型函数将相关字符传输到目标中并添加终止空字符。这可能很明显；但是，如果使用 c 说明符，则不会添加该空终止符。这些差异必须记住或每次都查找。

printf 输出也存在一些问题。在某些情况下，它的说明符与 scanf 的说明符不同。在此示例中，double 变量使用 f 说明符，但没有使用 lf，就像在 scanf 中一样。必须记住这一点。将输出文本与说明符混合在一个字符串中是可以理解的，但它确实引入了一些认知不 连续性，因为变量是在格式字符串之后列出的。从左到右阅读还需要在字符串和变量之间来回跳转（并且必须严格保持它们的顺序）。

最后，如果说明符和变量类型之间出现变量不匹配，会发生什么情况？清单 6.1 中的示例两次错误指定了 mice；第一次应该是 buffer。当使用整数变量作为 C 风格字符串？肯定不会有什么好事发生；可怕的未定义行为才是正确答案。我的系统发出分段错误，温和地提醒我有些东西坏了，但不会通过继续执行来欺骗我。

这些函数系列不是类型安全的，因此使用起来存在风险。很容易出现预期格式说明符与实际数据类型不匹配的情况。鉴于这些有限的错误检测能力，有意义的恢复代码非常复杂。

\mySamllsection{解决}

C 语言为我们提供了 scanf 和 printf 功能；但是，我们使用 C++ 进行编程，它有更好的选项。任何时候将字符数据移入或移出程序时，都应使用流。流提供了非常有用的插入和提取运算符（分别为 <{}< 和>{}>）。这些运算符确定如何将文本转换为正确的数据类型（假设输入数据与数据类型一致），并使开发人员不再需要数据类型说明符。

清单 6.2 中的错误编码（其中 mice 输出两次）不会导致运行时错误或歪曲数据——输出不正确，并且没有像清单 6.1 中那样从一种类型到另一种类型的错误转换。如果数据一致，则将文本数据提取到各种变量中可以正常工作，但当数据不一致时会失败。scanf 的问题在于输入和转换是一次性发生的；如果发生错误，开发人员必须从返回值中确定哪个转换失败了。清单 6.1 中的检测逻辑更加比清单 6.2 更简单，但至少第二个版本为开发人员提供了对错误检测的更细粒度的控制。

\filename{清单6.2 使用类型确定转换}

\begin{cpp}
int main() {
  std::istringstream str("3.14159 042 boxes .3");
  double pi;
  int cats;
  int mice;
  std::string buffer;

  str >> pi; // 1
  if (str.fail())
    std::cout << "error reading value 1\n";
  str >> cats;
  if (str.fail())
    std::cout << "error reading value 2\n";
  str >> buffer;
  if (str.fail())
    std::cout << "error reading value 3\n";
  str >> mice;
  if (str.fail())
    std::cout << "error reading value 4\n";

  std::cout << pi << " being eaten by " << cats << " cats in " << mice
    << " along with " << mice << " mice\n"; // 2
  return 0;
}
\end{cpp}

{\footnotesize
注释1：输入和转换工作正常或设置容易被检测到的fail()函数

注释2：转换基于实际数据
}

整数值 042 被正确转换为值 42；前导零不会影响其含义。如果数据确实是八进制，则可以将输入流设置为 8 进制以进行输入操作。此代码将输入并将 cats 转换为八进制：

\begin{cpp}
str >> std::setbase(8) >> cats;
\end{cpp}

\mySamllsection{建议}

\begin{itemize}
\item
尽可能用更适合流式传输的提取和插入运算符替换 scanf 和printf 调用。

\item
避免使用复杂的输入和输出格式字符串；它们很难正确使用，甚至更难阅读。
\end{itemize}
