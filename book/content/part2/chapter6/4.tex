这个问题主要集中在正确性和可读性上。编译器理解 C++ 类型，程序员试图转换它们可能会让类型检查机制措手不及。

\mySamllsection{问题}

编译器中的类型检查系统旨在防止将一种类型与另一种类型错误匹配。虽然人类可能看不出某些类型之间的区别，但编译器更了解情况，并会阻止许多转换，除非程序员坚持要转换并告诉编译器退出。这种方法非常有效 - 编译器会闭嘴 - 但可能会导致难以发现且调试起来很麻烦的错误。

清单 6.7 中的代码在某些系统上运行良好。它使用 union 来描述一个包含四个字符和一个整数的数组。程序员打算将整数转换为字符并将其输出到二进制文件。联合 mixer 简化了小字符数组和整数之间的转换。整数被写入联合实例；其值在 write 函数调用中读取。在我的系统上，这运行良好。

\filename{清单6.7 使用联合进行类型转换}

\begin{cpp}
static const int bytes_per_int = 4; // 1
  union mixer {
  char ch[bytes_per_int]; // 2
  int n;
};
int main() {
  mixer converter;
  converter.n = 42;
  std::ofstream out("data.txt", std::ios::binary);
  out.write(converter.ch, bytes_per_int);
  return 0;
}
\end{cpp}

{\footnotesize
注释1：整数总是四个字节

注释2：这里是假设
}

\mySamllsection{分析}

union 为字符数组保留四个字节，并用整数覆盖它。这在具有四字节整数的系统上有效，但它在任何地方都有效吗？当编译器版本更改时，它是否有效？也许；答案是 yes 和 yes，但不要指望它在别人的系统上也能工作。不能保证整数占用四个字节。当然，程序员可以检查这个值并对其进行硬编码；但是，这种解决方案是不可移植的。
union 不能有效地处理动态内存以自动将字符数组调整为整数大小。

\mySamllsection{解决}

非提升的类型转换的根本问题是程序员对大小、位和字节的底层布局做出了假设。这些假设意味着代码本质上是僵化的和不可移植的。由于这些假设，程序员引发的转换是有问题的，但如果必须编码，则应尽可能让编译器参与进来提供帮助。

清单 6.8 中显示的 reinterpret\_cast 带有编译器提供的整数大小，是一种更好的方法。没有程序员必须确定和验证的硬编码大小；编译器在编译时会根据特定架构计算出它。

二进制流有意义的少数几个地方之一是用户定义类型转换同样有意义的地方。转换为字符（实际上是字节）的数据永远不会以转换后的形式使用。使用 reinterpret\_cast 的相应指针转换从字符回到原始数据类型应该完全反转以防止出现异常和错误。

\filename{清单6.8 合理地使用reinterpret\_cast}

\begin{cpp}
int main() {
  int n = 42;
  std::ofstream out("data.txt", std::ios::binary);
  out.write(reinterpret_cast<const char*>(&n),
    sizeof(n)); // 1
  return 0;
}
\end{cpp}

{\footnotesize
注释1：编译器确定正确的大小；不做任何假设
}

尽管如此，以不需要用户定义类型转换的方式设计程序仍然是更好的选择。信任底层数据类型并使用类来聚合不同的数据类型。将实现细节推送给编译器，并尽可能在更高的级别上工作。

另外两个可能需要用户定义类型转换的地方是 API 的接口边界和与其他语言的模块集成。在这些情况下，尽可能使用编译器来协助转换工作。此外，将转换代码隔离为执行转换的文档齐全、小型、单一用途的函数。每次编译器、系统级别和架构发生变化时，都要检查这些函数的假设。

\mySamllsection{建议}

\begin{itemize}
\item
尽可能避免用户定义的、依赖于实现的类型转换。

\item
在需要时，尽可能避免硬编码假设；使用编译器来帮助。

\item
仔细记录每个出现对话代码的地方；明确每个假设，以便维护程序员可以在不可避免的变化发生时根据需要修改它们。
\end{itemize}










