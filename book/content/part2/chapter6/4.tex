这个问题主要集中在正确性和可读性上。编译器理解 C++ 类型，开发者试图转换它们，可能会让类型检查机制措手不及。

\mySamllsection{问题}

编译器中的类型检查系统，旨在避免将一种类型与另一种类型错误匹配。虽然人类可能看不出某些类型之间的区别，但编译器更了解情况，并会阻止许多转换，除非开发者坚持要转换，并告诉编译器退出。这种方法非常有效 - 编译器会闭嘴 - 但可能会导致难以发现，且调试起来很麻烦的错误。

清单 6.7 中的代码在某些系统上运行良好，使用 union 来描述一个包含四个字符和一个整数的数组。开发者打算将整数转换为字符并将其输出到二进制文件。联合 mixer 简化了小字符数组和整数之间的转换。整数写入联合实例；其值在 write 函数调用中读取。在我的系统上，这运行良好。

\filename{清单6.7 使用联合进行类型转换}

\begin{cpp}
static const int bytes_per_int = 4; // 1
  union mixer {
  char ch[bytes_per_int]; // 2
  int n;
};
int main() {
  mixer converter;
  converter.n = 42;
  std::ofstream out("data.txt", std::ios::binary);
  out.write(converter.ch, bytes_per_int);
  return 0;
}
\end{cpp}

{\footnotesize
注释1：整数总是四个字节

注释2：这里只进行了假设
}

\mySamllsection{分析}

union 为字符数组保留四个字节，并用整数覆盖。这在具有四字节整数的系统上有效，但在任何地方都有效吗？当编译器版本更改时，是否有效？也许；答案是 yes 和 yes，但不要指望在别人的系统上也能工作。不能保证整数占用四个字节。当然，开发者可以检查这个值并对其进行硬编码，但这种解决方案是不可移植的。union 不能有效地处理动态内存，自动将字符数组调整为整数大小。

\mySamllsection{解决}

非提升的类型转换的根本问题是开发者对大小、位和字节的底层布局做出了假设。这些假设说明代码僵化且不可移植。由于这些假设，开发者引发的转换是有问题的，但如果必须编码，则应让编译器参与进来提供帮助。

清单 6.8 中显示的 reinterpret\_cast 带有编译器提供的整数大小，是一种更好的方法。没有开发者必须确定和验证的硬编码大小；编译器在编译时，会根据特定架构计算出其大小。

二进制流有意义的少数几个地方之一，是用户定义类型转换同样有意义的地方。转换为字符(实际上是字节)的数据永远不会以转换后的形式使用。使用 reinterpret\_cast 转换的指针，应该完全反转为原始类型，以避免出现异常和错误。

\filename{清单6.8 合理地使用reinterpret\_cast}

\begin{cpp}
int main() {
  int n = 42;
  std::ofstream out("data.txt", std::ios::binary);
  out.write(reinterpret_cast<const char*>(&n),
    sizeof(n)); // 1
  return 0;
}
\end{cpp}

{\footnotesize
注释1：编译器确定正确的大小；不做任何假设
}

尽管如此，以不需要用户定义类型转换的方式设计程序仍然是不错的选择。信任底层数据类型，并使用类来聚合不同的数据类型。将实现细节推送给编译器，并尽可能在更高的级别上工作。

另外两个可能需要用户定义类型转换的地方是， API 的接口边界和与其他语言的模块集成。这些情况下，尽可能使用编译器来协助转换工作。此外，将转换代码隔离为执行转换的文档齐全、小型、单一用途的函数。每次编译器、系统级别和架构发生变化时，都要检查这些函数。

\mySamllsection{建议}

\begin{itemize}
\item
尽可能避免用户定义的、依赖于实现的类型转换。

\item
需要时，尽可能避免硬编码假设；使用编译器来帮助。

\item
记录每个出现对话代码的地方；明确每个假设，以便开发者可以在变化发生时，根据需要对其进行修改。
\end{itemize}










