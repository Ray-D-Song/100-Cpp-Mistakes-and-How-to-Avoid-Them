
这个错误与有效性、性能以及可读性有关。异常规范告诉编译器函数可以抛出哪些异常。

\mySamllsection{问题}

自 2011 年以来，异常规范已被弃用，因为它们的有效性和性能从未实现让开发人员的生活更轻松的承诺。它们很复杂，而且令人困惑不已，以至于现代 C++ 在 C++11 规范中弃用了它们，并在 C++17 标准中完全删除了它们。请仔细阅读 P0003R5 (\url{https://mng.bz/N1mE}) 了解整个故事。然而，源于异常规范的一个想法仍然适用且有意义。

异常是将正常功能流程与错误处理区分开的绝妙方法。这种灵活性是有代价的，这是意料之中的。大量使用异常和不使用异常一样令人反感。相反，我们必须找到一个合理的平衡点，既能提供明确的错误处理，又能提供良好的性能。许多函数不会抛出任何异常；因此，它们不应该因为在运行时检查是否处理任何潜在异常而受到惩罚。异常规范有一种情况是指定了 throw()，这意味着函数不会抛出任何内容。此规范的目标是提高性能。随着规范的删除，这种方法也消失了。

删除异常规范的提议承认了 throw() 的价值，并主张不要删除该功能，而是对其进行转换。C++11 标准添加了一个新运算符，该运算符实际上执行了与空抛出规范相同的操作。引入了 noexcept 运算符，其含义与空抛出相同，允许编译器执行优化以删除运行时异常检查。以下代码演示了前现代 C++ 方法，以说服编译器消除不必要的异常检查。

\filename{清单2.3 传达前现代不抛出异常行为的函数}

\begin{cpp}
const double pi = 3.1415927;
struct Circle {
  double radius;
  Circle(double r) : radius(r) {}
  double perimeter() const throw() { return 2 * pi * radius; } // 1
  double area() const throw() { return pi * radius * radius; } // 1
};

int main() {
  Circle c(3);
  std::cout << "perimeter " << c.perimeter() << ", area " << c.area() << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：由于没有抛出异常而尝试进行优化
}

\mySamllsection{分析}

清单 2.3 展示了前现代方法。其意图是好的，但会在现代 C++ 中引发警告消息。它不会发出错误，因为删除异常规范的提案认为空的throw() 应被视为等同于 noexcept(true) 规范。该参数是一个表达式，如果将其评估为 true，则编译器确信该函数不会引发任何异常； 确保您的代码不会欺骗编译器。

需要注意的是：如果标记为 noexcept 的函数恰好撒谎并引发异常，则会调用臭名昭著的 terminate 函数，这会立即终止程序，并且不会执行任何堆栈展开（不会调用析构函数！）。开发人员必须说实话，因为编译器会惩罚未定义（意外异常）行为。

\mySamllsection{解决}

清单 2.4 将上一个清单更新为现代方法，用新的语言关键字 noexcept 替换空的 throw() 规范。只需很少的更改即可正确传达函数不抛出任何异常的意图；因此，更新代码应该很简单。请记住，这仅适用于空的异常规范。

\begin{cpp}
struct Circle {
  double radius;
  Circle(double r) : radius(r) {}
  double perimeter() const noexcept { return 2 * std::numbers::pi * radius; } // 1
  double area() const noexcept { return std::numbers::pi * radius * radius; } // 1
};

int main() {
  Circle c(3);
  std::cout << "perimeter " << c.perimeter() << ", area " << c.area() << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：更好的优化尝试，因为没有抛出任何异常
}

接受一个参数的构造函数称为 conversion constructor。清单 2.4 中的代码可以将 double 值转换为 Circle 值。当编译器查找此类转换时，它会确定是否有可用的构造函数或转换操作，如果找到一个或多个，则使用最合适的。但是，这种行为只是有时需要的。

\begin{myNotic}{NOTE}
现代 C++ 提供了 explicit 关键字，以防止在隐式转换中使用单参数构造函数。有时，需要隐式转换行为，但通常，不受控制的转换构造函数应该受到限制。添加到构造函数的 explicit 关键字可防止编译器使用它进行转换。请仔细考虑这一点，并参阅另请参阅部分了解更多详细信息。
\end{myNotic}

\mySamllsection{建议}

\begin{itemize}
\item
将 throws() 更改为 noexcept 以使代码现代化。

\item
确保声称不会抛出异常的函数不会抛出异常。
\end{itemize}











