这个错误影响了有效性和可读性。当定义一个类时，一些成员如果不是由开发人员编写的，则由编译器自动提供。

\mySamllsection{问题}

编译器可以轻松处理没有开发人员编写的成员来处理构造、复制和赋值的简单类。开发人员未提供的内容，编译器将自动生成。通常，这是有帮助的，并且提供的版本可以完成必要的操作；当自动提供的方法不正确或不足时，开发人员必须编写自己的版本。

如果提供了任何构造函数，编译器将不会生成默认构造函数。如果编写了复制构造函数、移动构造函数或析构函数，则不会自动生成这些函数。此外，如果不应提供某些成员，一种简单的方法是将它们设为私有的，不实现任何功能。

这个问题的另一面是，一些开发人员在不明确需要时编写了许多这些提供的成员。开发人员编写了一个简单的 Container 类，提供了 一些基本功能。此外，他们决定复制是可以的，但是赋值不是。因此，以下代码提供了默认（必需）和复制构造函数，并隐藏了赋值运算符。

\filename{清单2.7 带有显式默认构造函数的简单类}

\begin{cpp}
class Container {
private:
  std::vector<int> values;
  Container& operator=(const Container& o); // 1
public:
  Container() {}
  Container(const Container& o) values(o.values) {}
  void add(int n) { values.push_back(n); }
};

int main() {
  Container c1;
  c1.add(42);
  Container c2(c1); // 2
  // c2 = c1; // 3
  return 0;
}
\end{cpp}

{\footnotesize
注释1：隐藏起来，所以没人能写赋值

注释2：调用复制构造函数。

注释3：赋值会出现错误。
}

\mySamllsection{分析}

代码可以运行，但编写和阅读起来比必要的更具挑战性。构造函数和赋值运算符通常是公共成员，因此将它们隐藏在私有部分中感觉很别扭。此外，这种方法不能很好地传达默认构造函数或赋值运算符的用途—— 必须熟悉该模式才能理解它。如果类比此示例稍微复杂一些，则默认构造函数中的代码需要更多努力。

\mySamllsection{解决}

一种更好的方法是使用 =delete 和 =default 关键字，它可以很好地记录意图。=delete 关键字表示成员是故意省略的；因此，不能使用它。=default 关键字表示编译器应该生成一个以默认方式运行的成员，因为它理解语义。这种用法的价值在于，类可以更改其实现而不会影响任何客户端代码，前提是这些更改对编译器来说是明确的。最好的原因是开发人员传达了这些成员的意图。

\filename{清单2.8 带有默认和删除成员的简单类}

\begin{cpp}
class Container {
private:
  std::vector<int> values;
public:
  Container() = default; // 1
  Container(const Container& o) : values(o.values) {}
  Container& operator=(const Container& o) = delete; // 2
  void add(int n) { values.push_back(n); }
};

int main() {
  Container c1;
  c1.add(42);
  Container c2(c1);
  // c2 = c1; // 3
  return 0;
}
\end{cpp}

{\footnotesize
注释1：编译器知道它在做什么。让它编写默认构造函数。

注释2：没有必要羞愧地隐藏该操作符；编译器会阻止它的使用。

注释3：赋值错误。
}

\mySamllsection{建议}

\begin{itemize}
\item
使用 =delete 消除成员，从而删除该功能。

\item
使用 =default 让编译器生成成员，节省时间并消除潜在错误源。
\end{itemize}




























