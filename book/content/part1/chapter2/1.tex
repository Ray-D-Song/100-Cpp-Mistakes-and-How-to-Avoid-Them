这个错误主要针对性能。将信息从一个区域传输到另一个区域可能代价高昂，因为数据通常会被复制，从而产生两个（或更多）版本的数据。

\mySamllsection{问题}

通常，数据必须在一个地方创建或构建，而在另一个地方进行分析或操作。将数据从一个地方复制到另一个地方效率很低，因为数据是重复的。复制少量数据似乎无害，但复制大量数据就会造成问题，尤其是如果经常这样做的话。

如果多个实体必须拥有数据，则数据是共享的。通常可以通过传递指针副本来实现大量共享数据，从而允许各种代码段访问数据而无需复制任何数据。通常，数据是独占的。传递这种数据的指针可能会很危险，因为指针本质上是一种共享机制。现代 C++ 为这种情况提供了独特的所有权智能指针。

数据通常由值而不是指针唯一拥有和管理。考虑清单 2.1 中的代码，其中TextSection在一个实例中创建并初始化，然后传递给另一个实例。p1 对象独占 TextSection，所有权和数据“转移”到 p2；至少，这是意图。结果是 p2 拥有数据的单个副本，但此路径成本高昂。请注意，源对象的数据和标头被销毁，保留了唯一所有权要求，但打破了为源传递 const 引用的常见做法。

\filename{代码清单2.1 一个保持唯一性的赋值操作符，但代价高昂}

\begin{cpp}
class TextSection {
  // assume a clever implementation
};

class Page {
private:
  TextSection* headers;
  TextSection* body;
public:
  Page(TextSection* h) : headers(h), body(new TextSection()) {}
  Page(Page& o);
  ~Page() { if (body) delete body; }
};

Page::Page(Page& o) {
  if (this == &o)
    return;
  body = new TextSection(*o.body);
  delete o.body;
  o.body = 0;
  headers = o.headers;
  o.headers = 0;
}

int main() {
  Page p1(new TextSection());
  Page p2 = p1; // 1
  return 0;
}
\end{cpp}

{\footnotesize
注释1：未定义行为的赋值操作
}

\mySamllsection{分析}

数据的副本归 p2 所有，但并非原始数据。这种情况会导致产生两份副本，并且需要花费时间来复制它。如果数据量很大，复制的时间可能会相当长。复制构造函数会销毁复制的数据，从而将副本数减少为一份，但无法最大限度地降低复制成本。转移所有权的努力值得称赞，但可以更高效。我们需要的是一种无需复制即可转移数据的方法。

\mySamllsection{解决}

现代 C++ 提供了一种称为 右值 引用的新引用类型（我将它们视为“右引用”），它引用运算符右侧的值。右值是赋值的源；它不能是赋值的目标。这意味着尽管右侧不是赋值目标，也可以对其进行修改。临时变量也是右值，因此修改它们是没有意义的，但窃取它们的值是合法的。新语法将包含一个双引用字符 (\&\&) 来指示移动语义。

该语言提供了添加移动构造函数和移动赋值运算符的功能。这些新功能旨在在资源从源转移到目标时保留独占所有权，并增加了移动数据而不是复制数据的好处。由于目标在移动后拥有转移的数据，因此应在源中使其失效以防止错误访问，如以下清单所示。

\filename{清单2.2 开销可忽略的保持唯一性的赋值操作符}

\begin{cpp}
class TextSection {
  // assume a clever implementation
};

class Page {
private:
  TextSection* headers;
  TextSection* body;
public:
  Page(TextSection* h) : headers(h), body(new TextSection()) {}
  Page(const Page& o) : headers(o.headers), body(new // 1
  TextSection(*o.body)) {}
  Page(Page&& o) : headers(o.headers), body(o.body) { // 2
    o.headers = nullptr; // 3
    o.body = nullptr;
  }
  ~Page() { delete body; }
};

int main() {
  Page p1(new TextSection());
  Page p2 = std::move(p1); // 4
  return 0;
}
\end{cpp}

{\footnotesize
注释1：一个可移动的复制构造函数

注释2：源资源被重新分配给目标。

注释3：源资源失效。

注释4：这看起来有点奇怪，但有正确的语义。
}

移动意味着源对象将其内容释放到目标对象。一些实现使用交换函数将源数据移动到目标，将目标数据移动到源。由于数据被重新分配，源对象不再拥有其原始数据，但拥有目标的数据通常是可以接受的。如果不使用交换操作，最好的方法是确保源中所有移动的数据都无效。

在源对象未被破坏的情况下，其先前的数据在任何情况下都不能被访问。我们都知道can出错了will出错了，而且通常，最多也只能这样尴尬的时候。因此，中和源对象中的数据，以防止在移动后被无意使用。这通常可以通过将指针设置为 nullptr（或 0）来实现。

另一个不错的功能是，当提供移动构造函数和赋值运算符时，编译器会尽一切合理努力尽可能使用它们。开发人员不必决定何时可以使用它们。当源是 lvalue（运算符左侧的可赋值值）时，将使用标准复制构造函数和赋值运算符。

std::move 函数模板对于正确移动至关重要。业界对此的流行语是“移动不动”。那么，它为何如此重要？移动将左值转换为右值，这使得它们符合移动语义。如果不这样做，将发生标准赋值，而不是移动赋值。使用复制和移动运算符，类可以提供共享赋值（或构造）或独占赋值（或构造），这使得语义更加清晰。

\mySamllsection{建议}

\begin{itemize}
\item
向类添加移动构造函数和赋值运算符，以独占方式转移资源所有权。

\item
通过包含移动构造函数和移动赋值运算符，将三规则（复制构造函数、赋值运算符、析构函数）扩展为 五规则。
\end{itemize}
















