此错误会影响正确性并增强可读性。RAII 模式应该管理动态资源，但可能需要编写多个管理类。前现代 C++ 提供了 auto\_ptr 选项，由于容易出错而被弃用，后来被删除。

\mySamllsection{问题}

动态资源的独占所有权对于跟踪唯一资源至关重要。此类资源无法复制，因为这样做会使源和目标代表单一资源。此时拥有和管理资源的引用尚不确定。此外，它留下了两者可能试图通过修改或删除来管理它的可能性；后者可能会导致双重删除错误。第一个 delete 可以正常工作，但第二个会将程序带入未定义行为的幻想世界，任何事情都可能发生 - 恳求编译器崩溃。

以下代码展示了管理唯一动态资源的简单案例。由于资源在一个地方创建，在另一个地方操作，因此必须传递其指针值。尽管代码是按顺序编写的，但阅读时要像每行被其他代码分隔开一样，这会造成足够的干扰，导致流程不明显 — 就像许多现实世界的项目一样！

\filename{清单2.15 管理独占资源的失败尝试}

\begin{cpp}
struct Buffer {
private:
  int* data;
public:
  Buffer() : data(new int[10]) {}
  ~Buffer() { delete[] data; }
};

int main() {
  Buffer* b1 = new Buffer();
  Buffer* b2 = b1; // 1
  if (b1)
    delete b1; // 2
  if (b2)
    delete b2; // 3
  return 0;
}
\end{cpp}

{\footnotesize
注释1：糟糕！独占资源不应被复制或分配

注释2：这似乎合理；这是原始所有者

注释3：这似乎不合理；这是第二位所有者
}

\mySamllsection{分析}

问题在于，开发人员的本意是在一个地方创建动态资源，然后稍后将其转移给另一个所有者。但是，与许多善意的想法一样，代码需要更 好地实现这一点。由于指针被复制，因此它变为共享的，而不是独占的。事实上，原始所有者 b1 删除了资源看起来合理，但忽略了所有权转移的尝试。如果所有权转移正确完成，则 b2 的删除是合理的。然而，由于资源已被删除，此尝试会导致未定义的行为，将程序带入操作的“暮光之城”。

Buffer 结构设计合理，应该能够正确管理其动态资源，因为它已经实现了 RAII 模式。但它还可以改进，如下所示。

\mySamllsection{解决}

使用原始指针管理动态资源的问题在于，在正常和异常情况下管理指针本身的复杂性。RAII 模式旨在处理这种情况，但需要对每个动态资源进行新的实现。auto\_ptr 尝试认识到了这个问题并试图提供通用解决方案；然而，这种拙劣的努力导致了重大问题并产生了奇怪的代码。

现代 C++ 已提供 std::unique\_ptr 以实现独占所有权。此模板设计精良，在任何条件下都能按预期工作。清单 2.16 中的代码演示了它与指针和数组的用法（auto\_ptr 无法处理数组）。Buffer 类的内部数据使用数组形式，并让 unique\_ptr 管理其动态数据。此类不需要用户编写的析构函数来处理数组删除。

与使用 new 相比，std::make\_unique 函数模板（见清单 2.16 ）更受欢迎。它具有更高的异常安全性，更直接，避免了原始指针，并且性能更高——有时，您可以拥有一切！

在所有权转移中，代码使用 std::move 函数模板。虽然这似乎将对象从一个所有者移动到另一个所有者，但事实并非如此 — 换句话说，“ 移动不会移动”。std::move 所做的是将左侧（左值）引用转换为右侧（右值）引用。右值引用通常是一个临时值，不可寻址，保存值，并复制到接收实体，如果是临时的，则在丢弃之前。move 操作使源实体在所有权方面有效地可丢弃。编译器将注意到何时使用右值实体的分配（ 或副本），并调用移动语义。值从源移动到目标，使源（概念上）为空并耗尽值。一些实现使用交换来传输值，使源保留目标的先前值。无论如何，除非重新初始化，否则不应使用源实体。我认为，最好将移动的实体视为不可访问和不可用。这种方法更容易推理。

\filename{清单2.16 使用 unique\_ptr 实现独占所有权}

\begin{cpp}
struct Buffer {
private:
  std::unique_ptr<int[]> data; // 1
public:
  Buffer() : data(std::make_unique<int[]>(10)) {} // 2
};

int main() {
  auto b1 = std::make_unique<Buffer>(); // 3
  auto b2 = std::move(b1); // 4
  return 0;
}
\end{cpp}

{\footnotesize
注释1：数组形式

注释2：数组形式的初始化

注释3：指针形式并使用首选的 make\_unique 函数模板

注释4：使用 move 函数模板进行所有权转移（而不是复制或赋值）
}

清单 2.16 中提供的解决方案更加简洁，尽管可能需要一些练习才能掌握。这种方法的价值比之前的任何方法都更高效、更简洁。请注意使用auto 关键字来指定 b1 和 b2. 的类型，因为编译器可以明确地推断它们的类型，所以它比您自己指定确切的类型更有效。

\mySamllsection{建议}

\begin{itemize}
\item
拒绝对任何动态资源使用原始指针；一般来说，对除共享资源之外的任何指针使用 unique\_ptr。

\item
使用 unique\_ptr 表示独占所有权，请记住，分配会将资源从源转移到目标，从而使源不可用。

\item
出于效率和简单性的考虑，最好使用 unique\_ptr；使用 shared\_ptr 成本更高。
\end{itemize}













