此错误会影响正确性，并增强可读性。RAII 模式应该管理动态资源，但可能需要实现多个管理类。经典 C++ 提供了 auto\_ptr 选项，由于容易出错而弃用，后来在标准中删除。

\mySamllsection{问题}

动态资源的独占所有权对于跟踪独占资源至关重要。此类资源无法复制，这样做则表示源目标独占此资源。此时，拥有和管理资源的引用尚不确定。此外，有两种通过修改或删除来管理方式；后者可能会导致双重删除错误。第一个 delete 可以正常工作，但第二个会出现未定义行为。

以下代码展示了管理独占动态资源的简单案例。由于资源在一个地方创建，在另一个地方操作，因此必须传递其指针值。尽管代码按顺序编写，但阅读时要将每行分隔开，这就会造成干扰，导致流程不明显。

\filename{清单2.15 管理独占资源的失败尝试}

\begin{cpp}
struct Buffer {
private:
  int* data;
public:
  Buffer() : data(new int[10]) {}
  ~Buffer() { delete[] data; }
};

int main() {
  Buffer* b1 = new Buffer();
  Buffer* b2 = b1; // 1
  if (b1)
    delete b1; // 2
  if (b2)
    delete b2; // 3
  return 0;
}
\end{cpp}

{\footnotesize
注释1：糟糕！独占资源不应复制或分配

注释2：这似乎合理；原始所有者

注释3：这似乎不合理；第二位所有者？！
}

\mySamllsection{分析}

开发人员的本意是在一个地方创建动态资源，然后稍后将其转移给另一个所有者。但与许多善意的想法一样，代码需要更好地落实。由于复制指针，因此变为共享而非独占。原始所有者 b1 删除了资源看起来合理，但忽略了所有权转移的尝试。如果所有权正确转移，则删除 b2 也合理。但由于资源已删除，此尝试会导致未定义行为。

Buffer 结构设计合理，已经实现了 RAII 模式，所以能够正确管理其动态资源。但还有改进的空间。

\mySamllsection{解决}

正常和异常情况下管理指针很复杂，RAII 模式旨在处理这种情况，但需要对每个动态资源进行实现。auto\_ptr 认识到了这个问题，并试图提供通用解决方案；然而，这种拙劣的努力导致了重大问题，并产生了很多奇怪的代码。

现代 C++ 提供 std::unique\_ptr 以实现独占所有权。此模板设计精良，在任何情况下都能按预期工作。清单 2.16 中的代码演示了它与指针和数组的用法(auto\_ptr 无法处理数组)。Buffer 类的内部数据使用数组形式，并让 unique\_ptr 管理动态数据。此类不需要用户编写的析构函数来删除数组。

与使用 new 相比，std::make\_unique 函数模板(见清单 2.16 )更受欢迎，具有更高的异常安全性，避免了裸指针的使用，并且性能更好。

所有权转移中，代码使用 std::move 函数模板。虽然这似乎将对象从一个所有者移动到另一个所有者，但事实并非如此 — 换句话说，“ 移动不会移动”。std::move 所做的是将左侧(左值)引用转换为右侧(右值)引用。右值引用通常是一个临时值，不可寻址，保存值，并复制到接收实体。移动操作使源实体丢弃所有权，编译器将知晓何时使用右值实体的分配(或副本)，并调用移动语义。值从源移动到目标对象，使源(概念上)为空值。一些实现使用交换来传输值，可使源保留目标的先前值。无论如何，除非重新初始化，否则不应使用源实体。我认为，最好不访问和不使用移动后的实体。

\filename{清单2.16 使用 unique\_ptr 实现独占所有权}

\begin{cpp}
struct Buffer {
private:
  std::unique_ptr<int[]> data; // 1
public:
  Buffer() : data(std::make_unique<int[]>(10)) {} // 2
};

int main() {
  auto b1 = std::make_unique<Buffer>(); // 3
  auto b2 = std::move(b1); // 4
  return 0;
}
\end{cpp}

{\footnotesize
注释1：数组形式

注释2：初始化数组

注释3：指针形式，使用首选的 make\_unique 函数模板

注释4：使用 std::move 函数模板进行所有权转移(非复制或赋值)
}

清单 2.16 中提供的解决方案更加简洁，可能需要一些练习才能掌握。这种方法的价值比之前的方法都高效和简洁。可以使用auto 关键字来指定 b1 和 b2 的类型，编译器可以推断它们的类型。

\mySamllsection{建议}

\begin{itemize}
\item
拒绝对动态资源使用原始(裸)指针，对除共享资源之外的指针使用 unique\_ptr。

\item
使用 unique\_ptr 表示独占所有权，分配会将资源从源实体转移到目标实体，从而使源实体不可用。

\item
出于效率和简单性的考虑，最好使用 unique\_ptr，因为使用 shared\_ptr 的成本更高。
\end{itemize}













