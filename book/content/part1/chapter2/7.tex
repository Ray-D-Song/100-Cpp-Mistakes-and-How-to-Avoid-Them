这个错误与可读性有关，并且在一定程度上与有效性有关。NULL 宏继承自 C，但在前现代 C++ 中，更好的方法是用零初始化指针。

\mySamllsection{问题}

清单 2.13 展示了一个包含几个实例变量的 Student 类的简单模型。其中一个实例变量被初始化为零值。此外，由于代码需要实例指针，我们看到它们的初始化被赋值为零值。读取文字零可能会造成混淆，因为该值在多个上下文中使用。

\filename{清单2.13 零值的混合使用}

\begin{cpp}
struct Student {
  std::string name;
  int id;
  double gpa;
  Student(const std::string& name, int id, double gpa) : name(name),
          id(id), gpa(0) {
    if (gpa < 0)
      throw std::invalid_argument("gpa is negative");
  }
};

int main() {
  Student* sammy = 0; ❶
  Student* ginny = 0;
  Student* gene = 0;
  sammy = new Student("Samuel", 0, 3.75);
  ginny = new Student("Virginia", 1, 3.8);
  gene = new Student("Eugene", 2, 0);
  return 0;
}
\end{cpp}

{\footnotesize
注释1：比 NULL 宏更好，但效果不那么明显
}

\mySamllsection{分析}

将指针初始化为零值是最好的方法，而前现代 C++ 必须表示不代表现有对象的指针。但是，文字零不是指针，它可能会导致短暂的混乱。虽然许多开发人员都熟悉这种用法，但它比不受欢迎的 NULL 宏更难读。至少宏作为 pointer 概念脱颖而出（尽管在大多数实现中可能不是） 。编译器足够聪明，可以获取整数文字值并正确使用指针。

\mySamllsection{解决}

然而，现代 C++ 提供了 nullptr，即表示空值的文字值，专门用于指针。其最显著的优点是意图清晰；其目的易于理解和快速掌握。零值不具备这种易用性。

此文字的另一个明显优点是编译器不会将其与类型为 int 的函数参数混淆。先前的错误表明了这种混淆；请参阅“另请参阅”部分以进一步说明。

\filename{清单2.14 使用 nullptr 明确指针状态}

\begin{cpp}
struct Student {
  std::string name;
  int id;
  double gpa;
  Student(const std::string& name, int id, double gpa) : name(name),
          id(id), gpa(0) {
    if (gpa < 0)
      throw std::invalid_argument("gpa is negative");
  }
};

int main() {
  Student* sammy = nullptr; // 1
  Student* ginny = nullptr;
  Student* gene = nullptr;
  sammy = new Student("Samuel", 0, 3.75);
  ginny = new Student("Virginia", 1, 3.8);
  gene = new Student("Eugene", 2, 0);
  return 0;
}
\end{cpp}

{\footnotesize
注释1：这比 NULL 宏更好，比零值更明显。有什么不喜欢的呢？
}

\mySamllsection{建议}

\begin{itemize}
\item
使用 nullptr 初始化未立即初始化为有效对象的指针。

\item
在删除nullptr 后立即为其分配一个指针，以防止出现释放后使用错误。
\end{itemize}
