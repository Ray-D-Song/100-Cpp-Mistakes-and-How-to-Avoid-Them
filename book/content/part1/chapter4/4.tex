这个错误会严重影响效率。开发人员编写映射、过滤或减少数据的代码的方法通常冗长乏味，而且大部分代码都集中在日常琐事上。

\mySamllsection{问题}

数据容器代表一种高效而紧凑的处理值序列的方法。向量是一种很好的选择，因为它们易于使用、灵活且功能强大。然而，使用它们所需的代码本质上需要完成一些琐碎的任务，这会分散开发人员对所要解决的问题的注意力已解决。基于范围的 for 循环是朝着更函数式编程迈出的重要一步，并暗示了使用数据流的可能性。

我们的开发人员必须获取一系列值，将所有负数转换为其绝对值，消除奇数值，并对剩余值求和。清单 4.8 是完成这项工作的直接方法，代表了处理序列的常用方法。前两个循环可以压缩为一个，但操作会更加晦涩难懂。一次执行一个功能方面更直接，但性能会降低。与往常一样，在大多数情况下，我更喜欢可读性而不是性能。

\filename{清单4.8 值序列上的几个独立函数}

\begin{cpp}
int main() {
  std::vector<int> vals { 42, 3, 7 -9, 0, 22, 23, -7, 22 };

  for (auto v : vals) ❶
    if (v < 0)
      v = -v;

  std::vector<int> evens; ❷
  for (const auto v : vals) ❸
    if (v % 2 == 0)
      evens.push_back(v);

  int sum = 0;
  for (const auto v : evens) ❹
    sum += v;

  std::cout << sum << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：将负值转换为对应的正值

注释2：为简单起见，新建一个容器

注释3：否定的值会被过滤掉

注释4：对第二个容器中的所有值求和
}

\mySamllsection{分析}

代码执行了开发人员需要实现的功能。发生了什么、它打算如何工作以及结果意味着什么，这些都很简单明了。但是，循环重复表明应该使用更好的方法。不幸的是，选择很少。压缩前两个循环是可能的，但会对可读性产生负面影响。第二个容器也感觉很别扭。正确地修改一个向量很有挑战性；使用第二个向量来保持干净和正确。这也会影响性能。

\mySamllsection{解决}

数据序列的优点是它们可以作为流进行处理。cin 和 cout 对象使用此方法。文件输入和输出遵循数据流模型。此模型引人注目，应尽可能使用其方法。使用它们的开销减少了，并且操作它们所需的代码也最小化了。C++ 引入了范围标头，其中包含范围和视图来操作值流。这些将代码减少到最低限度，尤其是在使用 lambda 时。

范围的一个明显优势是函数是可组合的。这意味着可以按顺序一个接一个地调用函数。一个简单的类比是命令行或脚本中使用的 Linux 过滤程序。第一个过滤函数的输出被馈送到下一个过滤函数作为其输入；其输出成为下一个过滤函数的输入，依此类推。通常，这种过滤器 组合称为 pipeline，这是一个有益且有意义的术语。

下面的代码介绍了处理数据流的三种基本函数形式：

\begin{itemize}
\item
映射

\item
过滤

\item
归约
\end{itemize}

理解 filter 一词的第二种用法很重要。Linux 示例代表传统名称；在范围上下文中，它表示一种功能。它们是相关的，但不等同。清单 4.9 中的代码演示了两个函数的组合，即绝对值和偶数谓词。

映射是一种函数，它获取输入流中的每个元素，对元素执行函数，并生成另一个元素，该元素将放入输出流中。此功能是一对一生成 — 每个输入值恰好产生一个输出值。std::views::transform 范围适配器附带一个函数，该函数将输入值映射或转换为输出值。以下代码调用 abs 函数将任何负值转换为正值。正值未经修改，表明转换可能不 会影响值，但会将其传递。每个值都映射到其绝对值。

过滤是一个函数，它接受输入流中的每个元素并确定是否应将该元素传递到输出流。它采用一个确定包含或拒绝的谓词。predicate 是一个返回布尔值的函数。如果返回值为 true，则保留该元素； 如果返回值为 false，则拒绝（消除）该元素。

清单 4.9 过滤掉奇数值，只保留偶数值。此功能是一对一或一对无的产生式；要么保留值，要么什么都不保留。std::views::filter 范围适配器被提供给谓词函数来确定元素包含或排除。根据谓词的返回值，每个值都被过滤掉或保留。请仔细阅读“另请参阅”部分以了解有关 lambda 的讨论。

最后，reduction 是一个函数，它获取输入流中的每个元素并对其执行 某些操作，从而产生单个结果值。该函数使用输入流中的每个元素来得出最终值。一个典型的例子是求和。清单 4.9 中的代码将过滤后的值相加以得出它们的总和。此功能是多对一的产生——每个输入元素都会对最终的单个值做出贡献。std::accumulate 函数模板采用迭代器作为第一个和最后一个元素以及一个初始值（求和时为零）。所有输入值都缩减为它们的总和。

C++ 范围和范围适配器功能强大，但尚未达到其他语言提供的性能水平。accumulate 函数无法与映射和过滤功能的结果组合，因为开发人员必须提供开始和结束迭代器。因此，必须创建第二个容器来保存流水线流值的结果。将来，可能会开发累积式范围适配器。几种函数式语言提供了许多可组合函数，使用起来很愉快。

\filename{清单4.9 值序列上的组合函数}

\begin{cpp}
int main() {
  std::vector<int> vals { 42, 3, 7 -9, 0, 22, 23, -7, 22 };

  auto evens = vals
    | std::views::transform([](int x) { return abs(x); })
    | std::views::filter([](int x){ return x % 2 == 0; }); // 1
  auto sum = std::accumulate(evens.begin(), evens.end(), 0); // 2

  std::cout << sum << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：创建一个流，将值绝对化，过滤掉奇数，并存储在一个新容器中

注释2：对第二个容器中的值求和
}

\mySamllsection{建议}

\begin{itemize}
\item
范围可以显著减少传统容器处理代码的开销。

\item
尽可能使用范围和范围适配器来处理容器，以简化编写和读取代码。

\item
请记住，并非所有面向范围的函数都可以在管道中组合。

\item
函数式编程功能强大，可以使用管道过渡到该范式。
\end{itemize}










