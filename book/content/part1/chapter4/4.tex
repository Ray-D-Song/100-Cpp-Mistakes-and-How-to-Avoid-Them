这个错误会严重影响效率。开发人员编写映射、过滤或减少数据的方法通常非常乏味，而且大部分代码都集中在琐事上。

\mySamllsection{问题}

数据容器代表一种高效而紧凑的处理值序列的方法。vector是一种很好的选择，易于使用、灵活且功能强大。然而，使用它们所需的代码本质上需要完成一些琐碎的任务，这会分散开发人员对所要解决的问题的注意力。基于范围的 for 循环是朝着更函数式编程迈出的重要一步，并使用了数据流。

开发人员会获取一系列值，将所有负数转换为其绝对值，消除奇数值，并对剩余值求和。清单 4.8 是完成这项工作的直接方法，代表了处理序列的常用方法。前两个循环可以压缩为一个，但操作会更加晦涩难懂。一次执行一个功能方面更直接，但性能很差。与往常一样，我更关注可读性，而非性能。

\filename{清单4.8 值序列上的几个独立功能}

\begin{cpp}
int main() {
  std::vector<int> vals { 42, 3, 7 -9, 0, 22, 23, -7, 22 };

  for (auto v : vals) // 1
    if (v < 0)
      v = -v;

  std::vector<int> evens; // 2
  for (const auto v : vals) // 3
    if (v % 2 == 0)
      evens.push_back(v);

  int sum = 0;
  for (const auto v : evens) // 4
    sum += v;

  std::cout << sum << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：将负值转换为对应的正值

注释2：简单起见，新建一个容器

注释3：过滤掉奇数

注释4：对第二个容器中的所有值求和
}

\mySamllsection{分析}

代码执行了开发人员需要实现的功能。发生了什么、如何工作，以及结果意味着什么，这些都很简单明。循环意味着应该使用更好的方法，但选择很少。可以压缩前两个循环，但会对可读性产生负面影响。第二个容器也感觉不是很舒服。正确地修改vector很有挑战性；使用第二个vector来保持干净和正确，也会影响性能。

\mySamllsection{解决}

数据序列的优点是可以作为流进行处理，cin 和 cout 对象使用此方法。文件输入和输出遵循数据流模型。此模型引人注目，应尽可能使用其方法，并且操作其所需的代码也进行了最小化。C++ 引入了范围头文件，其中包含范围和视图来操作值流。尤其是在使用 Lambda 时，可将代码量减少到最低。

范围的明显优势是函数可组合，可以按顺序逐个调用函数。第一个过滤函数的输出可送到下一个过滤函数，作为其输入；其输出成为下一个过滤函数的输入，依此类推。通常，这种过滤器组合称为“流水线”。

下面的代码介绍了处理数据流的三种基本函数形式：

\begin{itemize}
\item
映射

\item
过滤

\item
归约
\end{itemize}

映射是一种方法，可获取输入流中的每个元素，对元素执行相应的操作，并生成另一个元素，该元素将放入输出流中。此功能是一对一生成 — 每个输入值恰产生一个输出值。std::views::transform 范围适配器附带一个函数，该函数将输入值映射或转换为输出值。以下代码调用 abs 函数将任何负值转换为正值。正值不修改，表明转换可能不会影响值，但会将其传递。每个值都会映射到其绝对值。

过滤是一个函数，接受输入流中的每个元素，并确定是否应将该元素传递到输出流。它采用一个确定包含或拒绝的谓词，是一个返回布尔值的函数。如果返回值为 true，则保留该元素； 如果返回值为 false，则拒绝(消除)该元素。

理解过滤的第二种用法很重要。Linux 示例的传统名称；在范围上下文中，其表示一种功能。两种用法相关，但不等同。清单 4.9 中的代码演示了两个函数的组合，即绝对值和偶数谓词。

清单 4.9 过滤掉奇数值，只保留偶数值。此功能是一对一或一对无的产生式；要么保留值，要么什么都不保留。std::views::filter 范围适配器使用谓词函数，来确定元素包含或排除。根据谓词的返回值，每个值都可过滤掉或保留。

最后，归约是一个功能，获取输入流中的每个元素并对其执行某些操作，从而产生单个结果值。该函数使用输入流中的每个元素来得出最终值，典型的例子是求和。清单 4.9 中的代码将过滤后的值相加以得出其总和。此功能是多对一的产生——每个输入元素都会对最终的单个值做出贡献。std::accumulate 函数模板采用迭代器作为第一个和最后一个元素以及一个初始值(求和时为零)，所有输入值都缩减为它们的和。

C++ 范围和范围适配器功能强大，但尚未达到其他语言的性能水平。accumulate 函数无法与映射和过滤功能的结果组合，所以开发人员必须提供开始和结束迭代器。通过创建第二个容器来保存流水线流值的结果，未来可能会开发累积式范围适配器。几种函数式语言提供了许多可组合函数，使用起来很融洽。

\filename{清单4.9 值序列上的组合函数}

\begin{cpp}
int main() {
  std::vector<int> vals { 42, 3, 7 -9, 0, 22, 23, -7, 22 };

  auto evens = vals
    | std::views::transform([](int x) { return abs(x); })
    | std::views::filter([](int x){ return x % 2 == 0; }); // 1
  auto sum = std::accumulate(evens.begin(), evens.end(), 0); // 2

  std::cout << sum << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：创建一个流，将值绝对化，过滤掉奇数，并存储在一个新容器中

注释2：对第二个容器中的值求和
}

\mySamllsection{建议}

\begin{itemize}
\item
范围可以显著减少传统容器处理代码的开销。

\item
尽可能使用范围和范围适配器来处理容器，以简化编写和读取代码。

\item
并非所有面向范围的函数都可以在管道中组合。

\item
函数式编程功能强大，可以使用管道法过渡到该范式。
\end{itemize}










