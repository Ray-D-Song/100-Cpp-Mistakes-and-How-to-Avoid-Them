这种错误可以提高正确性、可读性和有效性；在某些情况下，它也会影响性能。初始化变量的方法有很多种，每种方法都有优点和缺点； 但是，这些方法必须更加一致。

\mySamllsection{问题}

C++ 使用从 C 继承的相同技术来初始化变量。但是，在某些情况下，C++ 超越了 C 的限制，引入了其他形式的初始化。已经引入了几种方法，但没有一种方法能以相同的方式完成其他方法所做的事情。最终结果是 C++ 代码有多种初始化变量的方法，并且它增加了认知负担以在适当的上下文中跟踪每种方法。请记住，编程思维应该专注于正在解决的问题并使用语言来表达解决方案——跟踪语言细节会增加不必要的负担，而不一致会降低效率。

以下代码是初始化整数向量的简单示例。前现代 C++ 没有其他方法可以做到这一点，因此需要额外的代码来设置问题。真是胡说八道！

\filename{清单3.10 容器和简单变量的典型初始化}

\begin{cpp}
int main() {
  std::vector<int> v;
  for (int i = 0; i < 10; ++i)
    v.push_back(i); // 1
  v.push_back(33); // 2
  v.push_back(42); // 2
  int count = v.size(); // 3
  std::cout << "the vector has " << count << " elements\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：可以使用循环来计算一致的值

注释2：不一致的值需要单独插入

注释3：通过赋值进行初始化
}

\mySamllsection{分析}

如果您只有 push\_back，那么您可能猜到了，每个初始化问题看起来都像 push\_back 问题。这种情况表明 C++ 有动力添加其他初始化方法；代码很笨重，需要付出很多努力才能完成一个简单的任务。可以展示其他几个示例，但这个示例可以满足目的。

\mySamllsection{解决}

使用统一初始化有几个原因；最吸引人的是它的一致性，这使得它在所有情况下都易于理解和适用。特别是对于容器，使用统一初始化的能力非常出色。清单 3.11 中的代码演示了对向量和独立变量的这种用法。当初始化值放在括号内时，它很快就会成为首选方法，尽管需要几次尝试才能理解。

统一初始化使用括号将初始化值括起来。vector 使用此方法，count 变量也使用此方法。随着开发人员变得更加熟练，这种统一性使编程变得更容易。放弃其他方法可能需要一些时间，但结果是值得的。

\filename{清单3.11 容器和简单变量的统一初始化}

\begin{cpp}
int main() {
  std::vector<int> v {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 33, 42}; // 1
  auto count {v.size()}; // 2
  std::cout << "the vector has " << count << " elements\n";
  return 0;
}
\end{cpp}

{\footnotesize
注释1：容器（复合变量）的统一初始化

注释2：变量的统一初始化（简单变量）
}

统一初始化使用一种形式来初始化任何变量。这种一致性使读写代码更易于管理。

使用此方法还有其他优点，其中包括：

\begin{itemize}
\item
不同变量类型之间的一致性

\item
不包括缩小转换 - 例如，double 不会默默初始化 int

\item
复杂的数据结构很容易初始化（有关更多信息，请查看指定的初始化）

\item
构造函数和容器的初始化列表支持
\end{itemize}

\mySamllsection{建议}

\begin{itemize}
\item
统一初始化可用于初始化任何变量，甚至是复杂变量。

\item
一旦理解并使用它，这种方法就一致且简单。
\end{itemize}
