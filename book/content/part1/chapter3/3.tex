
这个错误会影响可读性和有效性。类型别名通常用于从现有数据类型定义新数据类型。新类型更能表达类型的用途并提高可读性。

\mySamllsection{建议}

清单 3.6 中的代码使用 typedef 来定义一个可以更好地表达概念的新类型。这个概念是一个接受两个整数并返回一个整数的函数。MathFunction 的类型是一个函数指针，因此可以像任何函数一样分配和调用符合要求的函数。不明显的是别名嵌入在定义中。这种情况既不明显也不直观。

\filename{清单3.6 使用typedef来别名类型}

\begin{cpp}
typedef int (*MathFunction)(int, int); // 1

int add(int a, int b) {
  return a + b;
}

int sub(int a, int b) {
  return a - b;
}
int main() {
  MathFunction f = add; // 2
  std::cout << "Result of addition: " << f(5, 3) << std::endl;
  f = sub; // 2
  std::cout << "Result of subtraction: " << f(5, 3) << std::endl;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：从函数形式定义新类型

注释2：分配给新类型的变量
}

\mySamllsection{分析}

别名定义的尴尬之处是从 C 中继承下来的。C++ 仍然支持这种技术，并保留了其古怪的语法。如果新类型基于内置类型（例如 int），则可读性仍然会很奇怪，因为源类型位于目标类型之前，这与我们直观的预期相反。例如，将别名 age 定义为无符号整数将是

\begin{cpp}
typedef unsigned int age;
\end{cpp}

\mySamllsection{解决}

现代 C++ 引入了 using 关键字，这在很大程度上简化了别名类型。此关键字遵循更直观的方法，其中别名名称位于左侧，其定义位于右侧。赋值运算符使人们认为别名是从定义中分配的，就像常规算术赋值一样，从而增强了可读性。此外，编写别名更有效，因为它遵循直观的语法。

以下代码与清单 3.6 几乎完全相同；唯一的区别在于别名定义。这种相似性表明了两点：首先，使用别名类型与 typedef 版本相同；其次，没有理由继续使用 typedef 别名。

\filename{清单3.7 使用typedef为类型创建别名}

\begin{cpp}
using MathFunction = int (*)(int, int); // 1
int add(int a, int b) {
  return a + b;q
  }
  int sub(int a, int b) {
  return a - b;
}
int main() {
  MathFunction f = add; // 2
  std::cout << "Result of addition: " << f(5, 3) << std::endl;
  f = sub; // 2
  std::cout << "Result of subtraction: " << f(5, 3) << std::endl;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：类型名称与类型定义不同

注释2：用法相同
}

如果别名基于内置类型（例如 int），则可读性会增强，因为它很自然。例如，可以将别名 age 定义为无符号整数，如下所示：

\begin{cpp}
using age = unsigned int;
\end{cpp}

现在，专业人士提醒你：不要使用全局包容

\begin{cpp}
using namespace std;
\end{cpp}

在你的代码中（在源文件的顶部）。大多数教科书和许多在线教师都忽略了这条建议，使用这种全局包含显然是为了避免编码这样的困难

\begin{cpp}
std::cout << ...
\end{cpp}

std（标准）命名空间相当大，包含许多标识符。如果使用全局包含，您的代码具有同名标识符的可能性很高。猜猜编译器会使用哪一个？我也不知道。冲突和歧义的可能性很大，可能会导致未定义的行为——谁需要那样？调试这些情况并非易事；你应该好好休息一下。

\mySamllsection{建议}

\begin{itemize}
\item
始终使用 using 关键字而不是 typedef；这在任何情况下都是不利的。

\item
在任何使用 typedef 的代码中，将 typedef 替换为using。

\item
请记住，代码的读者值得付出努力。

\item
避免在代码中包含全局 using namespace std;。
\end{itemize}
