
每个代码库都可能包含错误，而这些错误的成因多种多样。多年来，C++ 开发者创建了无数应用程序，用以检测错误、过时的编码方式，弥补语言的不足，改进糟糕的设计，并优化低效的工具。如今，我们已经找到了一些方法来改善这些问题！通过研究开发方法学来应对失败，并引入新的语言特性来填补短板，我们正在逐步提升开发体验。

C++ 代码库中蕴含着大量的改进机会。一年或十年前编写的代码，通常基于当时的最佳实践和可用的语言特性。然而，随着时间推移，新的技术方法不断涌现，旧的设计与现代需求之间的不匹配也愈发明显。尽管知识和技能的进步有时能够直接转化为现有代码的改进，但技术债务和技术不一致却也在持续积累。这些问题不仅需要被支持和维护，还需要不断地修改、更新和调试。

遗憾的是，并非所有开发者都有机会或资源对代码进行重新设计或重写。业务场景中，当新功能实现成为优先事项时，改进现有代码往往会被忽视。然而，早期设计中的不良决策和做法所累积的技术债务，会直接影响到新功能的开发。这种技术债务通常表现为脆弱的代码：难以修改和扩展，甚至难以与其他新代码集成。面对这种情况，与其采取非此即彼的极端方式(修复旧代码或完全舍弃)，更理想的做法是识别并解决那些反复出现的问题模式。通过这种方式，我们可以逐步优化代码库，同时避免不必要的重构成本。

\mySubsubsection{1.1.1.}{简单的示例}

\textit{错误 57}中，如果构建了完整的产品并研究了结果输出，则会输出大量警告信息。分析编译输出时，有些警告信息会反复出现。一种选择是专注于特定的编译器警告，并在整个或大部分代码库中进行修复。以下代码显示了一个最小测试用例，其中通过三种方式发现了地址警告\texttt{-Waddress}。

清单 1.1 中的代码错误地进行了如下尝试：

\begin{itemize}
\item
调用函数但不使用必要的括号

\item
测试函数调用的返回值

\item
比较两个对象的值
\end{itemize}

\filename{清单1.1 带有编译器警告的代码示例}

\begin{cpp}
int cleanup() {
  return 0;
}

int main() {
  cleanup; // 1

  if (!(cleanup)) { // 2
    ...
  }
  const char* message = "Hello, world";
  if (message == "Hello, world") { // 3
    ...
  }
  return 0;
}
\end{cpp}

{\footnotesize
注释1：尝试不使用括号调用函数，结果只是一个地址，不会执行任何代码；需要通过添加括号进行修复

注释2：尝试使用返回值。使用函数地址，该地址始终为真(非零)，否定使其始终为假(零)，代码主体永远不会运行；需要通过添加括号来修复

注释3：将一个 const 指针与另一个 const 指针进行比较，该指针始终为假(不匹配)；需要通过 strcmp 函数或 C++ 字符串来比较进行修复
}

对于产生警告的代码库，如果团队已经在处理这些问题，并将其作为日常工作的一部分逐步解决，请明确告知其他开发人员和代码审阅者：相关代码在未来会有所改进。同时，可以寻求团队中其他成员的支持与协助，共同完成这一过程。需要注意的是，某些修复工作虽然表面上看起来简单，但实际上可能涉及复杂的情况。所以，在进行修复时，请务必保持谨慎，充分测试每一步改动，确保不会引入新的问题。此外，必须克制自己一次性修复过多问题的冲动(尽管这种想法可能非常诱人)，而是以缓慢而稳定的速度，每次只处理可控数量的问题。这种方式能够有效降低风险，确保代码库的稳定性。

另一种可行的方法是，在处理某个代码文件时，同时修复该文件中的多个问题。例如，正在修改某段代码以实现新功能或修复某个特定问题，可以借此机会有选择性地解决该文件中的其他问题。不过，与前面提到的方法一样，务必保持谨慎，避免因过度改动而导致意外后果。通过这种方式，可以有效地提升代码质量，同时减少对代码库整体的影响。



















