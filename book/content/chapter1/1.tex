
任何代码库中都可能出现错误，错误可能来自各种来源。多年来，C ++ 程序员研究了无数应用程序以发现错误：错误或过时的编码实践、语言缺陷、糟糕的应用程序设计和低效的工具。我们已经找到了 让事情变得更好的方法！已经发明了开发方法来解决开发失败，并且已经添加了语言功能来解决缺点。

典型的 C++ 代码库有很多改进的机会。一年或十年前编写的代码将使用当时流行且可用的实践和语言功能。随着时间的推移，新的方法不 断涌现，设计之间的不匹配也变得显而易见。知识和技术的进步有时只会转化为现有代码的改进。技术债务不断积累，不一致之处也成倍增加。这些问题必须得到支持、修改、更新和调试。

并非所有程序员都会重新设计或重写大量代码。当可以实现新代码或功能时，业务目标很少会提倡改进现有代码。然而，糟糕的选择和做法带来的债务会影响新开发。这种技术债务通常表现为难以更改且难以集成新代码的脆弱代码。与其选择非此即彼的方法，即旧代码基本得到修复或被忽视的，最接近理想的方法是发现和解决经常出现的模式。

\mySubsubsection{1.1.1.}{简单的示例}

例如，在Mistake 57 中，如果构建了完整的产品并研究了结果输出，则会列出大量警告。分析编译输出时，特定警告会反复出现。一种选择是专注于特定的编译器警告并在整个或大部分代码库中修复它。以下代码显示了一个最小测试用例，其中通过三种方式发现了地址警告-Waddress。

清单 1.1 中的代码错误地尝试

\begin{itemize}
\item
调用函数而不使用语法上必要的括号

\item
测试函数调用的返回值

\item
比较两个对象值
\end{itemize}

\filename{清单1.1 带有编译器警告的代码示例}

\begin{cpp}
int cleanup() {
    return 0;
}

int main() {
    cleanup; // 1
    if (!(cleanup)) { // 2
       ...
    }
    const char* message = "Hello, world";
    if (message == "Hello, world") { // 3
       ...
    }
    return 0;
}
\end{cpp}

{\footnotesize
注释1：尝试不使用括号调用函数，结果只是一个地址，不会执行任何代码；请通过添加括号来修复。

注释2：尝试使用返回值。函数地址被使用，该地址始终为真（非零），否定使其始终为假（零），代码主体永远不会运行；请通过添加括号来修复。

注释3：将一个 const 指针与另一个 const 指针进行比较，该指针始终为假（不匹配）；请通过使用 strcmp 类型函数或 C++ 字符串来比较指向的值来修复。
}

这些警告来自的代码库已将这些问题作为其他工作的一部分得到解决。如果选择这种方法，请告知其他开发人员和审阅者您打算随着时间的推移改进代码。最好征求其他团队成员的合作来协助此过程。请注意：有些修复并不简单，但看起来确实如此。谨慎、克制并进行充分测试。必须克制，这样您才不会试图同时修复太多问题（尽管很诱人），而是以缓慢而稳定的速度同时解决可控数量的问题。

另一种选择是修复一个代码文件中的多个问题。如果您正在处理该文件以修改代码，则可以轻松地有选择地解决其他问题。与上一种方法一样，请谨慎行事。



















