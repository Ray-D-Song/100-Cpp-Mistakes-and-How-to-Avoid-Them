
异常的主要目的是断言发生了错误，并且调用的代码无法成功完成请求。此错误以开发人员无法忽略的方式出现。传统的错误处理通常是设置某种状态值，来指示发生了错误，并且调用代码会针对这种情况进行测试；但没有办法强制执行错误检查。

异常会引起开发人员的注意。如果抛出异常而开发人员忽略，程序最终会崩溃。开发人员必须处理异常以避免崩溃——不可忽略的特性迫使开发人员解决这个问题。希望开发人员能够仔细考虑错误的含义，以及从错误中恢复可能需要做什么。换句话说，异常为设计具有弹性的软件提供了重要的机会。

需要考虑的异常时空方面有三个，依次为：

\begin{enumerate}
\item
功能调用点

\item
错误检测点

\item
恢复点
\end{enumerate}

调用点首先发生。调用一段功能性代码，调用者等待结果(我们这里只考虑同步执行)。错误检测点随后发生。这是直接检测错误情况的操作发生的地方。调用点后面的代码开始可选发生的恢复点。

对于经典的返回代码，这将是对返回值的检查；对于异常，是相关的捕获块。

这三个站点在空间上是分开的(不同的功能)，当调用代码确定它无法有意义地继续时，就会检测到错误。调用者要求被调用者执行一个行为，但调用者被到绝境，必须承认它无法执行。许多情况下，调用者的返回值都没有意义，必须在替代控制路径中发出错误信号。最后，恢复代码是空间和时间上的第三个站点。这个可选执行的代码试图从错误中恢复。如果可以，程序继续；如果不能，应该正常终止。

以下是对异常的几种肯定和反对意见。我们考虑了每种反对意见，并给出了使用异常的支持。简而言之，大多数对异常的反对意见与异常的正确使用关系不大；相反，它们反对的是不当使用。与任何技术一样，不当使用是有问题的，但不能成为拒绝正确使用的理由。

\mySubsubsection{10.1.1.}{肯定：混合控制和恢复路径}

传统的错误处理将控制和恢复路径混在一起；异常将它们分开。没有问题的正常执行路径(快乐路径)通常设计得很好，大多数开发者编写代码来执行行为。太频繁了，只有在快乐路径编码并工作后，错误检测和处理路径才会优先考虑——有时，只会得到一个粗略的一目了然。坦白地说，错误检测和错误处理代码经常会遮掩住主控制路径，从而难以理解和推理。

这种代码混淆，可能会让一些开发人员不太注意错误检测和处理的必要性。人们很容易希望事情能够正常工作(至少在大多数情况下)，而不必过分强调错误。此外，当调用的代码不太容易理解，或者调用代码隐藏在可能不太容易理解的条件时，处理错误通常只是猜测。无法清楚地理解错误的含义，可能会降低处理导致错误的能力。

\mySubsubsection{10.1.2.}{反对：混淆异常处理和正常错误处理}

在错误处理情况下，异常会过度使用。这里，区分调用点和检测点至关重要。检测错误的代码不应该直接抛出异常。相反，当检测点确定发生了错误时，必须决定是否可以处理它。如果可以，就没有必要抛出异常。当抛出异常时，读者可以正确地争辩说检测点代码应该处理这个问题。然而，当检测站点无法处理错误时，应该抛出异常。包括检测点在内的代码应该执行某种行为。当不能处理时，必须通过某种机制来发出信号表明其无能为力。通常，这是由错误返回码表示。但同样，没有什么可以强制调用点检查返回码。

使用异常来表示函数无法满足调用者的需求，是使用它们的正确理由。使用异常来要求调用者修复调用代码本应存在的问题是令人反感的，不应这样做。

\mySubsubsection{10.1.3.}{反对：难以改进异常处理}

大量现有代码中添加异常处理太难了。无论是否反对改造现有代码以添加异常处理，这都不是一个好主意。需要通过引入不一致、低效率和阅读和理解挑战，来将异常处理代码添加到逻辑中。现有代码可能没有返工的预算，但在某些情况下，可能会有返工的预算。新代码中设计一致的异常处理策略具有挑战性，在现有代码中则更困难。请尽你所能，但在这些情况下不要做得过火。

\mySubsubsection{10.1.4.}{肯定：歧义值}

异常将正常值与错误值区分开来。返回代码取决于定义的数据类型、该类型的特定值，以及用于检查该值的代码。该函数返回其定义的返回类型的值。返回代码是哨兵值。哨兵值与数据类型一致，但与问题不一致。假设一个函数返回一个整数值，确定与问题不一致的整数值可能很容易，但更有可能不会如此。必须确定单个值或一组值来表示良好的返回；必须指定不同的值或一组值来解决错误的返回。哪个是哪个？谁需要记住这些？并且能保证解释这些的注释和代码一致吗？

抛出异常是明确的，并且不依赖于函数的返回类型。异常类型包含信息。此外，异常可能还包含描述错误细节的附加文本信息。

\mySubsubsection{10.1.5.}{肯定：模棱两可的数据类型}

异常可确保值的数据类型在正常和错误条件下不同，使用返回代码或设置全局变量的传统方法，必须遵循返回代码的类型，该类型也用于正常处理。异常可以抛出与返回类型无关的完全不同的类型，异常的类型消除了返回数据类型的含义。

\mySubsubsection{10.1.6.}{肯定：强制错误处理}

使用异常可确保错误得到处理。异常不会强制执行适当的错误处理，仅确保捕获每个异常或终止程序。提供了有意义地处理错误的机会；开发人员必须充分利用。异常的一个显著好处是，简化了将错误渗透到更高级别的过程。这些级别通常可以更好地处理问题。使用返回代码会使渗透变得复杂，并且在每个级别进行测试时会令人困惑。

如果第一级错误处理不能充分处理错误，则只需稍微努力就可以重新抛出异常，或将其转换为另一个键入并抛出该异常。唯一的编码要求是每个级别，都有一些可以匹配抛出的异常的 catch 块。错误处理的替代控制结构简化了代码，并使推理更加清晰。

\mySubsubsection{10.1.7.}{反对：提供恢复处理程序}

Catch 块不必具有有意义的恢复处理。这几乎不是一个重大的反对意见，编写错误恢复代码都没必要，无论是异常还是经典方式。捕获异常的第一个块可以确定出了什么问题，以及是否可以恢复。恢复可能意味着调用函数修改的所有状态要么回滚，要么初始化到有意义的点。毫无疑问，可以忽略更改并继续前进，开发人员必须考虑这一点。必须遵守类的不变量，并在必要时恢复。调用代码之后的恢复代码，总是能更好地掌握可能已更改的内容，并需要清理的内容。发现本地的代码需要更多知识，才能进行有意义的恢复。

\mySubsubsection{10.1.8.}{肯定：转变失败类型}

为正常和错误情况使用单独的控制路径，允许开发人员在飞行过程中转换异常类型。如果检测点以一种方式理解错误，则恢复点可以将该语义转换为另一种含义。假设正在从磁盘文件读取一条记录，输入验证例程在将文本转换为特定字段的整数时检测到无效数据。它会抛出异常，指出发现了无效数据，转换无法成功。如果恢复点决定不恢复，可能希望将此故障推到另一个级别，添加元数据或其他诊断信息。较高级别应该了解一些比低级别细节更一般的信息(例如，输入不匹配错误)。因此，第一个恢复点可以将异常类型更改为更适合下一级恢复点的内容，可能是无效记录错误。日志记录可用于捕获细节，这可能不适合实际恢复。

\mySubsubsection{10.1.9.}{肯定：分离关注点}

能够在错误检测和错误处理之间分离关注点，让多个开发人员能够在不干扰彼此代码的情况下就近工作。混合正常和错误处理控制路径会混淆关注点，处理正常路径的代码与处理错误路径的代码的工作方式不同。因此，将这些路径分离为两个不同问题的能力，可以使每个关注点彼此隔离。这是一个强大的软件工程原则，只要可以应用，就应该尽可能地加以利用。

\mySubsubsection{10.1.10.}{反对：鼓励预先设计}

代码必须从一开始就设计为处理异常，这需要花费时间和精力。这种反对意见可能是允许在未进行适当设计之前，或未进行适当设计的情况下编写代码的原因，这与异常无关。新代码和尽可能多的遗留代码必须经过适当设计，以处理正常和错误路径处理的分离。
