
异常的主要目的是断言发生了错误，并且调用的代码无法成功完成请求。此错误以开发人员无法忽略的方式出现。传统的错误处理通常是设置某种状态值来指示发生了错误，并且调用代码会针对这种情况进行测试；但是，没有办法强制执行错误检查。

异常会引起开发人员的注意。如果抛出异常而开发人员忽略它，程序最终会崩溃。这种行为是不必要的，开发人员必须处理异常以防止崩溃——不可忽略的特性迫使开发人员解决这个问题。希望开发人员能够仔细考虑错误的含义以及从错误中恢复可能需要做什么。换句话说，异常为设计具有弹性的软件提供了重要的机会。

需要考虑的异常时空方面有三个，依次为：

\begin{enumerate}
\item
功能调用站点

\item
错误检测站点

\item
恢复站点
\end{enumerate}

调用站点首先发生。调用一段功能性代码，调用者等待结果（我们这里只考虑同步执行）。错误检测站点随后发生。这是直接检测错误情况的操作发生的地方。调用站点后面的代码开始可选发生的恢复站点。

对于经典的返回代码，这将是对返回值的检查；对于异常，它将是相关的捕获块。

这三个站点在空间上是分开的（不同的功能）。当被调用代码确定它无法有意义地继续时，就会检测到错误。调用者要求被调用者执行一个行为，但被调用者被逼到绝境，必须承认它无法执行。在许多情况下，被调用者的返回值都没有意义；因此，必须在替代控制路径中发出错误信号。最后，恢复代码是空间和时间上的第三个站点。这个可选执行的代码试图从错误中恢复。如果可以，程序继续；如果不能，它应该正常终止。

以下是对异常的几种肯定和反对意见。我们考虑了每种反对意见，并给出了使用异常的支持。简而言之，大多数对异常的反对意见与异常的正确使用关系不大；相反，它们反对的是不当使用。与任何技术一样，不当使用是有问题的，但不能成为拒绝正确使用的理由。

\mySubsubsection{10.1.1.}{肯定：混合控制和恢复路径}

传统的错误处理将控制和恢复路径混在一起；异常将它们分开。没有问题的正常执行路径（快乐路径）通常设计得很好，因为大多数程序员编写代码来执行行为。太频繁了，只有在快乐路径编码并工作后，错误检测和处理路径才会优先考虑——有时，它只会得到一个粗略的一目了然。坦白地说，错误检测和错误处理代码经常会遮掩住主控制路径，从而难以理解和推理。

这种代码混淆可能会让一些开发人员不太注意错误检测和处理的必要性。人们很容易希望事情能够正常工作（至少在大多数情况下），而不必过分强调错误。此外，当被调用的代码不太容易理解，或者调用代码隐藏在可能不太容易理解的条件下被调用的代码中时，处理错误通常只是猜测。无法清楚地理解错误的含义可能会大大导致错误处理 能力下降。

\mySubsubsection{10.1.2.}{反对：混淆异常处理和正常错误处理}

在错误处理情况下，异常被过度使用。在这里，区分调用站点和检测站点至关重要。检测错误的代码不应该直接抛出异常。相反，当检测站点确定发生了错误时，它必须决定是否可以处理它。如果可以，就没有必要抛出异常。当抛出异常时，读者可以正确地争辩说检测站点代码应该处理这个问题。然而，当检测站点无法处理错误时，它应该抛出异常。包括检测站点在内的代码应该执行某种行为。当它不能处理时，它必须通过某种机制来发出信号表明其无能为力。传统上，这是由错误返回码来表示的。但同样，没有什么可以强制调用站点检查返回码。

使用异常来表示函数无法满足调用者的需求是使用它们的正确理由。使用异常来要求调用者修复被调用代码本应存在的问题是令人反感的，不应这样做。

\mySubsubsection{10.1.3.}{反对：难以改进异常处理}

在大量现有代码中添加异常处理太难了。无论你是否反对改造现有代码以添加异常处理，这都不是一个好主意。你需要通过引入不一致、低效率和阅读和理解的挑战来将异常处理代码添加到逻辑中。现有代码可能没有返工的预算，但在某些情况下，可能会有返工的预算。在新代码中设计一致的异常处理策略具有挑战性，在现有代码中则要困难得多。请尽你所能，但在这些情况下不要做得过火。

\mySubsubsection{10.1.4.}{肯定：歧义值}

异常将正常值与错误值区分开来。返回代码取决于定义的数据类型、 该类型的特定值以及用于检查该值的代码。该函数返回其定义的返回类型的值。返回代码是标记值。sentinel value 与数据类型一致，但与问题不一致。假设一个函数返回一个整数值。确定与问题不一致的整数值可能很容易，但更有可能不会如此。必须确定单个值或一组值来表示良好的返回；必须指定不同的值或一组值来解决错误的返回。哪个是哪个？谁可以记住这些了吗？并且能保证解释这些的注释和代码一致吗？

抛出异常是明确的，并且不依赖于函数的返回类型。异常类型包含信息。此外，异常可能还包含描述错误细节的附加文本信息。

\mySubsubsection{10.1.5.}{肯定：模棱两可的数据类型}

异常可确保值的数据类型在正常和错误条件下是不同的。使用返回代码或设置全局变量的传统方法仍然必须遵循返回代码的类型，该类型也用于正常处理。异常可以抛出与返回类型无关的完全不同的类型。
异常的类型消除了返回数据类型的含义。

\mySubsubsection{10.1.6.}{肯定：强制错误处理}

使用异常可确保错误得到处理。异常不会强制执行 proper 错误处理； 它们仅确保捕获每个异常或终止程序。提供了有意义地处理错误的机会；开发人员必须充分利用它。异常的一个显著好处是它简化了将错误渗透到更高级别的过程。这些级别通常可以更好地处理问题。使用返回代码会使渗透变得复杂，并且在每个级别进行测试时会令人困惑。

如果第一级错误处理不能充分处理错误，则只需稍微努力就可以重新抛出异常或将其转换为另一个键入并抛出该异常。唯一的编码要求是每个级别都有一些可以匹配抛出的异常的 catch 块。错误处理的替代控制结构简化了代码，并使推理更加清晰。

\mySubsubsection{10.1.7.}{反对：提供恢复处理程序}

Catch 块不必具有有意义的恢复处理。这几乎不是一个重大的反对意见，因为编写任何错误恢复代码都很差，无论是异常还是经典，都是可能的。捕获异常的第一个块可以确定出了什么问题以及是否可以恢复。恢复可能意味着被调用函数修改的所有状态要么回滚，要么初始化到有意义的点。毫无疑问，可以忽略更改并继续前进。但是，开发人员必须彻底考虑这一点。必须遵守类不变量并在必要时恢复。调用代码之后的恢复代码总是能更好地掌握可能已更改的内容并需要清理 的内容。发现站点本地的代码需要更多知识才能进行有意义的恢复。

\mySubsubsection{10.1.8.}{肯定：转变失败类型}

为正常和错误情况使用单独的控制路径允许开发人员在飞行过程中转换异常类型。如果检测站点以一种方式理解错误，则恢复站点可以将该语义转换为另一种含义。例如，假设正在从磁盘文件读取一条记录。输入验证例程在将文本转换为特定字段的整数时检测到无效数据。它会抛出异常，指出发现了无效数据，转换无法成功。如果恢复站点决定不恢复，它可能希望将此故障推到另一个级别，添加元数据或其他诊断信息。较高级别应该了解一些比低级别细节更一般的信息（例如，输入不匹配错误）。因此，第一个恢复站点可以将异常类型更改为更适合下一级恢复站点的内容，可能是无效记录错误。日志记录可用于捕获细节，这可能不适合实际恢复。

\mySubsubsection{10.1.9.}{肯定：分离关注点}

能够在错误检测和错误处理之间分离关注点，让多个开发人员能够在不干扰彼此代码的情况下就近工作。混合正常和错误处理控制路径会混淆关注点。处理正常路径的代码与处理错误路径的代码的工作方式根本不同。因此，将这些路径分离为两个不同问题的能力可以使每个关注点彼此隔离。这是一个强大的软件工程原则，只要可以应用，就应该尽可能地加以利用。

\mySubsubsection{10.1.10.}{反对：鼓励预先设计}

代码必须从一开始就设计为处理异常，这需要额外的时间和精力。这种反对意见可能是允许在未进行适当设计之前或未进行适当设计的情况下编写代码的原因。这与异常无关。新代码和尽可能多的遗留代码必须经过适当设计，以处理正常和错误路径处理的分离。
