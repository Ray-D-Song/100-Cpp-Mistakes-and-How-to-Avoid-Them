本章内容

\begin{itemize}
\item
异常使用的缺点

\item
良好异常使用的好处

\item
资源处理和异常之间的关系

\item
构建异常层次结构以实现精确控制
\end{itemize}

异常这一话题在整个领域都有支持者和反对者，开发人员主张从很少使用异常（如果有的话）到经常使用异常。多年来，一些作者发表了 文章，为这一领域的各种立场辩护。其中许多论点是相关的，但它们与其他观点不太吻合。这种情况让我们在处理异常使用时陷入困境。

许多立场在特定问题领域中是正确的，但在其他领域中却存在问题。在许多情况下，一种政策是有意义的，但在其他情况下却毫无意义。需要在整个程序的范围内考虑异常。解决函数行为的策略可能无法有意义地扩展到更大的单元。许多当前在生产中运行的程序需要重新设计以处理统一的异常策略。在这些无数情况下，几乎任何设计都比没有设计要好。然而，将本地化策略集成到更大的单元中可能会令人沮丧且容易出错。

在这些众多的案例中，最好的方法是更好地理解例外情况，并培养应用这些例外情况的直觉知识应用于所考虑的代码库。因此，我们将从对异常及其存在原因的一般了解开始。从这一点开始，我们可以更好地理解如何在资源管理 等关键情况下很好地使用它们。异常和资源紧密联系在一起（以及构造函数和析构函数），以提供全面的管理模式，尤其是在夜间发生意外时。Bjarne Stroustrup 发明的惯用模式resource allocation is initialization (RAII) 将重点介绍为协调资源管理 的 C++ 方式。

使用异常的一个重要方面是明确什么是错误，什么不是错误。function 是执行某种行为的一段命名代码。每个代码都有三个必须保持的特征 — 任何未能保持这些特征的行为都应被视为错误：

\begin{itemize}
\item
先决条件失败

\item
不变量 失败

\item
后置条件失败
\end{itemize}

函数中发现的其他问题应在本地处理。如果这些问题是或成为这三个特征的失败，则应抛出异常。明确区分错误（以异常表示）和应在本地处理的问题可能很棘手。下面给出了每种类型的快速示例，以帮助阐述各种可能性：

\begin{itemize}
\item
Precondition failure— 向函数传递一个指向链接列表的指针以搜索键，但指针为 NULL（可能等于零）。由于函数不可能继续，因此必须发出错误信号。如果函数设计为处理空列表（NULL 指针） ，则这不是错误，应该返回一个值，表明未找到该键。

\item
Invariant failure— 类实例维护表示日期的状态。构造函数使用先决条件检查验证了范围。实例尚未被销毁，这意味着类不变量有效且不可违反。但是，某些方法修改了日期状态，导致日期超过了 31。另一种方法尝试转换此日期，但使用不变量检查发现了错误。由于检测到错误，因此应该发出信号。由于类本身修改了值，因此这是一个糟糕的编程案例！幸运的是，不变量检查传达了这种情况。

\item
Postcondition failure— 函数接收指向包含要转换为数字的文本的缓冲区的指针，但文本与数值不一致。由于函数无法返回有意义的数值，因此必须发出错误信号。如果函数旨在返回非值的数字表示形式（假设为浮点 NaN），则返回该值，并且不会出现错误。
\end{itemize}

应使用这三个特征一致且可预测地考虑其他情况。应该清楚的是，函数设计需要考虑这些，并且应仔细考虑什么是错误，什么不是错误。避免临时的错误策略——同情所有有遗留问题并必须清理的人。
