本章内容

\begin{itemize}
\item
异常的缺点

\item
异常的优点

\item
资源处理和异常

\item
构建异常层次结构以实现精确控制
\end{itemize}

异常这一话题在整个领域都有支持者和反对者，开发人员主张从很少使用异常(如果有的话)到经常使用异常。多年来，一些作者发表了文章，为这一领域的各种立场辩护。其中许多论点是相关的，但其他观点不太吻合。这种情况，让我们在处理异常使用时陷入困境。

许多情况下，一种政策是有意义的，但在其他情况下却毫无意义。需要在整个程序的范围内考虑异常，解决函数行为的策略可能无法有意义地扩展到更大的单元。许多当前在生产中运行的程序需要重新设计以处理统一的异常策略。在这些情况下，任何设计都比没有设计要好，但将本地化策略集成到更大的单元中可能会容易出错。

众多的案例中，最好的方法是更好地理解例外情况，并应用这些例外情况的直觉，应用于所开发的代码库。因此，我们将从对异常，及其存在原因的进行一般性了解。从这一点开始，可以更好地理解如何在资源管理等关键情况下，如何更好地使用它们。异常和资源紧密联系在一起(以及构造函数和析构函数)，以提供全面的管理模式，尤其是在夜间发生意外时。Bjarne Stroustrup 发明的惯用模式resource allocation is initialization (RAII) 将重点介绍为协调资源管理 的 C++ 方式。

使用异常的一个重要方面是明确什么是错误，什么不是错误。函数是执行某种行为的一段命名代码。每个代码都有三个必须保持的特征 — 未能保持这些特征的行为都应视为错误：

\begin{itemize}
\item
先决条件失败

\item
不变量失败

\item
后置条件失败
\end{itemize}

函数中发现的其他问题应在本地处理。如果这些问题是或成为这三个特征的失败，则应抛出异常。明确区分错误(以异常表示)和应在本地处理的问题可能很棘手。下面给出了每种类型的快速示例，以帮助阐述各种可能性：

\begin{itemize}
\item
先决条件失败 - 向函数传递一个指向链接列表的指针以搜索键，但指针为 NULL(可能等于零)。由于函数不可能继续，因此必须发出错误信号。如果函数设计为处理空列表(NULL 指针) ，则这不是错误，应该返回一个值，表明未找到该键。

\item
不变量失败 - 类实例维护表示日期的状态。构造函数使用先决条件检查验证了范围。实例尚未被销毁，所以类不变量有效且不可违反。但某些方法修改了日期状态，导致日期超过了 31。另一种方法尝试转换此日期，但使用不变量检查发现了错误。由于检测到错误，因此应该发出信号。由于类本身修改了值，因此这是一个糟糕的编程案例！幸运的是，不变量检查传达了这种情况。

\item
后置条件失败 - 函数接收指向包含要转换为数字的文本的缓冲区的指针，但文本与数值不一致。由于函数无法返回有意义的数值，因此必须发出错误信号。如果函数旨在返回非值的数字表示形式(假设为浮点 NaN)，则返回该值，并且不会出现错误。
\end{itemize}

这三个特征一致且可预测地考虑其他情况。应该清楚的是，函数设计需要考虑这些，并且应仔细考虑什么是错误，什么不是错误。避免临时的错误策略——同情所有有遗留问题并必须清理的人。
