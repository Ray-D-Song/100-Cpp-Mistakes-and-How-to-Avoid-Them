此错误主要针对性能。开发类时可能会创建过多的临时对象。了解创建它们的原因可帮助开发人员避免不必要的创建。错误地编写复制赋值运算符是可能创建过多临时对象的一个方面。

\mySamllsection{问题}

假设开发人员正在编写一个用于工程计算的程序包。客户需要的数据类型之一是复杂的数。C++ 在 complex 标头中提供了一个 complex 模板，但是为了 说明这个问题，开发人员将编写他们的类版本。

此代码旨在允许链式赋值，以遵守复制赋值运算符的优先级和结合性。它可以编译和运行，但在处理临时变量时存在一些问题。

\filename{清单9.11 一个类从拷贝赋值操作符返回一个临时对象}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}
  Complex operator=(const Complex& o) {
  Complex cpx(o.real, o.imag); // 1
    real = cpx.real;
    imag = cpx.imag;
    return cpx;
  }
};
int main() {
  Complex c1, c2, c3(1, 1);
  c1 = c2 = c3;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：也许是为了返回值优化而编写的？
}

\mySamllsection{分析}

复制赋值运算符应该修改实例的状态，这段代码就是这样做的；但是，开发人员以创建临时对象的方式编写了它。赋值的目标应该直接从参数中更新；在本例中，它被赋值从临时对象中创建临时对象。创建一个用该对象的值初始化的新对象并返回（可能是被过度使用 RVO 误导了）。RVO 的一个好处是它可以防止从返回的对象中创建另一个临时对象。这种方法很昂贵，因为它调用构造函数来创建临时对象并在使用后立即将其丢弃。

清单 9.11 中的用法调用了五次 Complex 构造函数。此外，初始化分配对象的对象不是其右侧的对象；而是从对象的一个不必要的副本中传输而来。

\mySamllsection{解决}

以下代码展示了一种更好的方法。它不返回对象的副本，而是返回对修改后对象的引用，以便使用实际对象（而不是副本）进行赋值。

\filename{清单9.12 从拷贝赋值操作符返回引用}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}
  Complex& operator=(const Complex& cpx) { // 1
    real = cpx.real;
    imag = cpx.imag;
    return *this; // 2
  }
};
int main() {
  Complex c1, c2, c3(1, 1);
  c1 = c2 = c3;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：写入修改目标对象

注释2：返回修改后的目标对象的引用
}

关键因素是复制赋值运算符返回的是对象的引用，而不是对象的副本。这种方法减少了用于创建临时返回对象的构造函数调用。返回值引用新更新的对象，无需复制对象。赋值的语义得以保留，并且不会创建任何临时对象。实际对象用于链接赋值。

这种方法应该用于所有赋值类型的运算符，而不仅仅是裸赋值。以下代码仅显示遵循此模式的 operator+=。所有其他复合赋值运算符都应遵循此模式。例如，复合加法运算符将按以下清单所示实现。

\filename{清单9.13 从复合操作符返回引用}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double r = 0.0, double i = 0.0) :
  real(r), imag(i) {std::cout<<"x\n";}
  Complex& operator+=(const Complex& cpx) { // 1
    real += cpx.real;
    imag += cpx.imag;
    return *this;
  }
};
int main() {
  Complex c1, c2, c3(1, 1);
  c2 += c3; // 2
  c1 += c2;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：重复既定模式

注释2：使用模式
}

\mySamllsection{建议}

\begin{itemize}
\item
了解运算符的标准使用模式，并确保类可以提供相同的方法。

\item
记住每个运算符的内置优先级和结合性，以确保代码遵循它们。

\item
确保类使用与内置数据类型相同的运算符方法；不要用一些奇特的、不直观的行为让客户端感到惊讶。
\end{itemize}
