这个错误主要集中在性能上，对正确性关注较少。C++ 允许开发人员重载操作符，以保持编写代码的一致方法。前缀和后缀增量和减量操作符，就是一个很好的例子。编写自定义减量操作符的方法与增量操作符非常相似，因此本讨论只需涵盖增量版本。

增量操作符有两种形式：前缀和后缀。这些形式可能看起来实现相同，并且性能相同。然而，这种直觉是误导性的。它们的实现不仅不同，而且结果类型也不同。这些差异表明它们的用途不同，性能也可能不同。

\mySamllsection{问题}

假设表示复数的数据类型在使用增量(减量)操作符时，单调增加(或减少)实部。一种简单的方法是创建一个 increment 函数，将复数值的实部加一。然而，这不是 C++ 的惯用方式，并且不能像使用增量操作符那样传达意图。

因此，开发者可能会将 operator++ 实现得更符合惯用语，他们应该谨慎决定操作符的返回类型。前缀和后缀版本必须返回不同的类型才能正确运行，这一点必须注意。

清单 9.16 中的定义以相同的方式实现了操作符的前缀和后缀版本，假设其实现相同。该语言使用空参数列表定义前缀版本，使用 int 参数定义后缀版本。该参数区分形式并且未使用，不应该有名称。

当一些“聪明”的开发者决定对变量进行双倍递增时，就会出现问题。这不仅在不应该发生的情况下起作用，而且没有按预期工作。在这种情况下，编译器会执行所要求的操作，但不会执行预期的操作。调试这个问题可能很困难。

\filename{清单9.16 前缀和后缀相同地实现}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double real = 0.0, double imag = 0.0) : real(real), imag(imag) {}
  void increment() { real += 1; }
  Complex operator++();
  Complex operator++(int);
friend std::ostream& operator<<(std::ostream&, const Complex&);
};

Complex Complex::operator++() { // 1
  real += 1;
  return *this;
}

Complex Complex::operator++(int) { // 2
  real += 1;
  return *this;
}

std::ostream& operator<<(std::ostream& out, const Complex& c) {
  out << '(' << c.real << ", " << c.imag << ')';
  return out;
}

int main() {
  Complex cpx(2.2, -1);
  cpx++;
  cpx++++; // 3
  ++cpx;
  ++++cpx; // 3
  std::cout << cpx << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：前缀操作符，返回对象本身

注释2：后缀操作符，返回对象本身

注释3：双倍递增不能正常工作，并且从语法上讲有效，但在语义上值得怀疑
}

\mySamllsection{分析}

示例代码显示了多个问题。首先，增量功能不符合惯用的 C++ 用法。这段代码错失了为数字(和迭代器)类型提供一致接口的机会。就可读性和有效性而言，操作符比函数更能传达意图。

其次，前缀和后缀版本之间的返回值或对象必须不同，其用法和语义不同。前缀形式应该在值修改后返回一个值或对象，后缀形式应该在值被修改之前返回一个值或对象。

第三，后缀版本的返回值或对象存在问题，因为它不是常量。这种情况允许修改返回的值或对象。“聪明”的开发者可能会错误地认为他们可以得到双倍的增量。第一次增量返回值或对象的副本，第二次增量返回副本的修改副本 - 第二次增量不会影响原始对象，原始对象只增加一次，所以增量的期望和现实是不匹配的。编译器不会试图教育这个开发者，而是希望防止这个错误在编译中出现。如果编译器没有检测到这个问题，聪明的做法将导致意外的行为，并且可能会出现一个漫长而奇怪的错误信息。

第四，这些操作符不是根据其他操作符实现的。实际上，随着代码的修改，会采用不同的方法。这种不一致性会滚雪球般发展，产生依赖于操作符使用顺序的行为——顺序的变化会产生不同的结果。前缀和后缀增量操作符的实现完全依赖于 operator+=。关于如何修改实例数据，应该尽可能地独立。这种情况下，三个操作符不需要重复。

\mySamllsection{解决}

正确实施后，operator++ 可以简化这些问题的解决，它遵循成熟的 C 和 C++ 习惯用法。使用操作符代替函数非常有效，而且可读性更高。

operator++(以及其他相关操作符)的实现应根据内置类型维护操作符的语义。如果操作正确，实现细节会随着时间的推移保持一致，从而避免因在类中重复知识而造成的麻烦。两种形式均根据operator+= 实现，其中最具体的操作符(增量)依赖于最通用的操作符。这种关注点分离使操作符的知识，有利于保持独立和一致。

需要考虑这些操作符的两个方面：实现细节和性能特征。增量操作符及其操作对象的文本顺序，揭示了它们之间的语义差异。前缀版本在获取对象值之前先递增；为是一种先更新再求值的方法——求值表达式会反映更新后的值。调用代码会看到实际对象的值是什么。

后缀版本应视为先求值再更新的方法——首先进行求值，保存对象的当前值，然后进行更新，并返回保存的值。求值并不反映对象的当前值，而是反映更新前的值。调用代码看到的是过去值，而不是现在值。这两个值之间存在时间差异。

由于后缀版本使用一个临时对象，来反映增量操作之前对象的值，因此必须返回一个值对象，而不是引用——不想返回对现已销毁本地对象的引用！

两个版本的操作符的返回类型已更正。前缀版本应返回对对象本身的引用，因为它是修改后的对象。“聪明”的开发者仍然可以执行双递增(可读性下降！)，因为引用的对象被正确修改，而不是副本。后缀版本不能返回对自身的引用，但必须返回对象先前值的副本。因此，必须返回一个值，而不是引用。为了防止出现双递增问题，使返回值 const 禁止修改它 — 如下面的清单所示，这也读起来也好多了。

\filename{清单9.17 语义正确的自增操作符的实现}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double real = 0.0, double imag = 0.0) : real(real), imag(imag) {}
  Complex& operator++();
  const Complex operator++(int);
  Complex& operator+=(int);
  friend std::ostream& operator<<(std::ostream&, const Complex&);
};

Complex& Complex::operator++() { // 1
  Return *this += 1; // implemented in terms of operator+=
}

const Complex Complex::operator++(int) { // 2
  Complex temp(*this);
  *this += 1; // implemented in terms of operator+=
  return temp;
}

Complex& Complex::operator+=(int n) {
  real += n;
  return *this;
}

std::ostream& operator<<(std::ostream& out, const Complex& c) {
  out << '(' << c.real << ", " << c.imag << ')';
  return out;
}

int main() {
  Complex cpx(2.2, -1);
  cpx++;
  //cpx++++; // 3
  ++cpx;
  ++++cpx;
  std::cout << cpx << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：前缀版本返回修改对象的对象引用

注释2：后缀版本返回未修改对象的副本

注释3：双后缀增量在语法上不再有效，但在语义上合理
}

循环体或更新部分中的后缀版本效率低于前缀版本，每次对对象调用后缀增量操作符时，对象都必须创建一个副本，其中执行内存分配；调用复制构造函数；返回的值永远不会使用(真是浪费)；匿名对象超出范围后，会调用析构函数。使用前缀版本的成本要低得多，返回一个引用，然后就完成了。

\mySamllsection{建议}

\begin{itemize}
\item
根据前缀增量(和减量)实现后缀增量(和减量)，并根据operator+= (operator-=) 实现前缀增量(和减量)，将如何修改值的知识本地化到单个位置。

\item
尽可能使用前缀形式，尤其是在循环体和循环更新部分，这可以最大限度地减少对象的副本数量。
\end{itemize}







