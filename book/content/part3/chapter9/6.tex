这个错误主要集中在性能上，对正确性关注较少。C++ 允许开发人员重载运算符以保持编写代码的一致方法。前缀和后缀增量和减量运算符就是一个很好的例子。编写自定义减量运算符的方法与增量运算符非常相似，因此本讨论只需涵盖增量版本。

增量运算符有两种形式：前缀和后缀。这些形式可能看起来实现相同，并且性能相同。然而，这种直觉是误导性的。它们的实现不仅不同，而且结果类型也不同。这些差异表明它们的用途不同，性能也可能不同。

\mySamllsection{问题}

假设表示复数的数据类型在使用增量（减量）运算符时单调增加（或减少）实部。一种简单的方法是创建一个 increment 函数，将复数值的实部加一。然而，这不是惯用的 C++，并且不能像使用增量运算符那样传达意图。

因此，程序员可能会将 operator++ 实现得更符合惯用语。他们应该谨慎决定运算符的返回类型。前缀和后缀版本必须返回不同的类型才能正确运行，这一点必须注意。

清单 9.16 中的定义以相同的方式实现了运算符的前缀和后缀版本，假设它们的实现相同。该语言使用空参数列表定义前缀版本，使用 int 参数定义后缀版本。该参数区分形式并且未使用；它不应该有名称。

当一些“聪明”的程序员决定对变量进行双倍递增时，就会出现问题。这不仅在不应该发生的情况下起作用，而且没有按预期工作。在这种情况下，编译器会执行所要求的操作，但不会执行预期的操作。调试这个问题可能很困难。有些事情完全不对劲。

\filename{清单9.16 相同地实现前缀和后缀}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double real = 0.0, double imag = 0.0) : real(real), imag(imag) {}
  void increment() { real += 1; }
  Complex operator++();
  Complex operator++(int);
friend std::ostream& operator<<(std::ostream&, const Complex&);
};
Complex Complex::operator++() { // 1
  real += 1;
  return *this;
}
Complex Complex::operator++(int) { // 2
  real += 1;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Complex& c) {
  out << '(' << c.real << ", " << c.imag << ')';
  return out;
}
int main() {
  Complex cpx(2.2, -1);
  cpx++;
  cpx++++; // 3
  ++cpx;
  ++++cpx; // 3
  std::cout << cpx << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：前缀运算符，返回对象本身

注释2：后缀运算符，返回对象本身

注释3：双倍递增不能正常工作，并且从语法上讲有效，但在语义上值得怀疑
}

\mySamllsection{分析}

示例代码显示了多个问题。首先，增量功能不符合惯用的 C++ 用法。虽然在某种程度上这是有道理的，但这段代码错失了为数字（和迭代器）类型提供一致接口的机会。就可读性和有效性而言，运算符比函数更能传达意图。

其次，前缀和后缀版本之间的返回值或对象必须不同，因为它们的用法和语义不同。前缀形式应该在值被修改后返回一个值或对象（ 我们将在后面讨论）；代码就是这样做的。后缀形式应该在值被修改之前返回一个值或对象（同样，稍后）；代码不会这样做，也不 能直接这样做。

第三，后缀版本的返回值或对象存在问题，因为它不是常量。这种情况允许修改返回的值或对象。“聪明”的程序员可能会错误地认为他们可以得到双倍的增量。第一次增量返回值或对象的副本，第二次增量返回副本的修改副本 - 第二次增量不会影响原始对象，原始对象只增加一次。因此，增量的期望和现实是不匹配的。编译器 不会试图教育这个程序员，而是希望防止这个错误在编译中出现。如果编译器没有检测到这个问题，聪明的做法将导致意外的行为，并且可能会出现一个漫长而奇怪的调试会话。

第四，这些运算符不是根据其他运算符实现的，实际上，随着代码的修改，会采用不同的方法。这种不一致性会滚雪球般发展，产生依赖于运算符使用顺序的行为——顺序的变化会产生不同的结果。前缀和后缀增量运算符的实现可以完全依赖于 operator+=。关于如何修改实例数据的知识应该尽可能地独立。在这种情况下，三个运算符不需要重复这些知识。

\mySamllsection{解决}

正确实施后，operator++ 可以简化这些问题的解决，因为它遵循成熟的 C 和 C++ 习惯用法。使用运算符代替函数非常有效，而且可读性更高。

operator++（以及其他相关运算符）的实现应根据内置类型维护运算符的语义。如果操作正确，实现细节会随着时间的推移保持一致，从而避免因在类中重复知识而造成的麻烦。两种形式均根据operator+= 实现，其中最具体的运算符（增量）依赖于最通用的运算符。这种关注点分离使运算符的知识保持独立和一致。

需要考虑这些运算符的两个方面：它们的实现细节和性能特征。增量 运算符及其操作对象的文本顺序揭示了它们之间的语义差异。前缀版本在获取对象值之前先递增；它被认为是一种先更新再求值的方法— —求值表达式会反映更新后的值。调用代码会看到实际对象的值是什 么。

后缀版本应被视为先求值再更新的方法——首先进行求值，保存对象的当前值，然后进行更新，并返回保存的值。求值并不反映对象的当前值，而是反映更新前的值。调用代码看到的是过去值，而不是现在值。这两个值之间存在时间差异。

由于后缀版本使用一个临时对象来反映增量操作之前对象的值，因此必须返回一个值对象，而不是引用——我们不想返回对现已被销毁的本地对象的引用！

两个版本的运算符的返回类型已更正。前缀版本应返回对对象本身的引用，因为它是修改后的对象。“聪明”的程序员仍然可以执行双递增（可读性下降！），因为引用的对象被正确修改，而不是副本。后缀版本不能返回对自身的引用，但必须返回对象先前值的副本。因此，它必须返回一个值，而不是引用。为了防止出现双递增问题，使返回值 const 禁止修改它 — 如下面的清单所示，这也读起来好多了。

\filename{清单9.17 语义正确的自增操作符的实现}

\begin{cpp}
class Complex {
private:
  double real;
  double imag;
public:
  Complex(double real = 0.0, double imag = 0.0) : real(real), imag(imag) {}
  Complex& operator++();
  const Complex operator++(int);
  Complex& operator+=(int);
  friend std::ostream& operator<<(std::ostream&, const Complex&);
};
Complex& Complex::operator++() { // 1
  Return *this += 1; // implemented in terms of operator+=
}
const Complex Complex::operator++(int) { // 2
  Complex temp(*this);
  *this += 1; // implemented in terms of operator+=
  return temp;
}
Complex& Complex::operator+=(int n) {
  real += n;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Complex& c) {
  out << '(' << c.real << ", " << c.imag << ')';
  return out;
}

int main() {
  Complex cpx(2.2, -1);
  cpx++;
  //cpx++++; // 3
  ++cpx;
  ++++cpx;
  std::cout << cpx << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：前缀版本返回被修改对象的对象引用

注释2：后缀版本返回未修改对象的副本

注释3：双后缀增量在语法上不再有效，但在语义上是合理的
}

循环体或更新部分中的后缀版本效率低于前缀版本 — 这是无法补救的。每次对对象调用后缀增量运算符时，对象都必须创建一个副本，其中执行内存分配；调用复制构造函数；返回的值永远不会使用（真是浪费）；匿名对象超出范围后，它会调用析构函数。使用前缀版本的成本要低得多，它返回一个引用，然后就完成了。

\mySamllsection{建议}

\begin{itemize}
\item
根据前缀增量（和减量）实现后缀增量（和减量），并根据operator+= (operator-=) 实现前缀增量（和减量），以将如何修改值的知识本地化到单个位置。

\item
尽可能使用前缀形式，尤其是在循环体和循环更新部分，这可以最大限度地减少对象的副本数量。
\end{itemize}







