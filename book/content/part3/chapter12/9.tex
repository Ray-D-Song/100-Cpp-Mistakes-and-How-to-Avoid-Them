这个错误影响正确性。将浮点值转换为整数值其实比听起来要复杂得多。

\mySamllsection{问题}

许多学生学习过 round 函数，应该始终使用浮点值和整数值之间的转换。他们可能还学习过使用强制类型转换进行截断。这两种方法当然会将浮点值转换为整数，但并不代表所有可能性。

下面的代码演示了这一基本理解，但缺少两个重要的转换函数。

\filename{清单12.17 使用截断和舍入将浮点数转换为整数}

\begin{cpp}
int main() {
  std::vector<double> values;
  values.push_back(3.14); values.push_back(2.71); values.push_back(1.5);
  values.push_back(-1.5); values.push_back(-2.71);
  values.push_back(-3.14);
  std::cout << "value trunc round\n";
  for (int i = 0; i < values.size(); ++i) {
    double v = values[i];
    std::cout << std::setw(5) << v
      << std::setw(6) << static_cast<int>(v)
      << std::setw(6) << round(v)
      << '\n';
  }
  return 0;
}
\end{cpp}

清单 12.17 中的代码输出演示了这两个转换函数：

\begin{shell}
value trunc round
 3.14     3     3
 2.71     2     3
  1.5     1     2
 -1.5    -1    -2
-2.71    -2    -3
-3.14    -3    -3
\end{shell}

\mySamllsection{分析}

上述代码的结果显示了这些常用函数，但这些结果不足以解决开发人员的所有问题。如果计算搬运 3.14 件物品所需的包装箱数量，这些转换函数将不会返回正确的值 4。翻转问题的符号，如果−\$3.14 是余额(即欠款金额)，需要对账户采取什么操作来偿还债务？提供的函数表明该账户需要 −\$3 操作(提取 3 美元)，而正确的响应将是 −\$4。计算必要结果的这些差距表明，需要其他函数来完成转换。

换句话说，如果只使用这两个函数，上述两个问题将需要其他代码来确定正确的行为，有时甚至会导致解决方案出错。更好的方法是使用一个对转换有意义的函数，而无需很复杂的逻辑。

\mySamllsection{解决}

除了典型的截断和舍入之外，将浮点值转换为整数时还必须考虑两个附加函数。我们将分析和描述这四个函数中的每一个，并给出一个示例来巩固解释。许多解释中，忽略了值的符号，这是一个错误。数值必须始终考虑值的全部范围。

截断应被认为是向零截断。这种添加意味着当值的小数部分截断时，结果值会朝特定方向移动。无论初始值是什么，当小数部分删除时，结果都会比以前更接近零。有关此移动的直观表示，请参见图 12.1。

\myGraphic{0.95}{content/part3/chapter12/images/1.png}{图12.1 几个函数的转换方向}

截断的一个例子是人的年龄(尽管很小的孩子似乎对小数年份很着迷)。生日之间的整年可视为精确浮点值的年龄，小数部分删除，所以截断值将向零移动，直到达到整数。一个 3.14 岁的人是三岁，直到他变成四岁。

转换中必须考虑 std::floor 函数。与截断函数不同，floor 函数从精确值移向负无穷大。图 12.1 演示了这一点。对于正值，看起来就像截断，但负值的工作原理却大不相同。

制造商就是底线函数的一个例子。考虑一家生产冰淇淋三明治的公司。如果一盒三明治有 12 件，而该公司生产了 150 件，那么只能制作 12 个盒子。没有人愿意买1盒后发现里面只有6个三明治(尽管如果他们将其作为减肥辅助品出售，可能会起作用)。

round 函数的工作原理与我们在算术中学到的相似 - 如果小于一半，则向较低值移动；如果大于一半，则向较高值移动；当恰好为一半时，通过向较高值移动来打破平局。图 12.1 显示了使用此函数移动的方向。将舍入描述为一种移动非常困难，这取决于值和符号。

一个简单的例子就是测验成绩：如果学生得分 89.6，就认为自己应该得 90 分。我总是尽量给学生打出有利的分数，但没有理由给得分 89.4 的人打 90 分。

最后，还必须考虑 std::ceil 函数，移动方向与 floor 函数相反。此函数始终朝正无穷大方向移动。任何小数部分都使其有资格移动到下一个最高整数值。有关此函数移动的图形描述，请参见图 12.1。

std::ceil 的一个例子是购买几加仑油漆用于装饰。假设一面墙的面积为 165 平方英尺，一加仑油漆可以覆盖 144 平方英尺。遗憾的是，家装中心不出售零碎加仑，所以必须购买 2 加仑油漆来粉刷这面墙。

清单 12.18 中的代码，在前面提到的函数中引入了 std::floor 和std::ceil 函数。问题的性质决定了使用这四个选项中的哪一个。处理小数部分对于现实世界的问题来说至关重要，若忽视它则会产生负面影响。

\filename{清单12.18 从浮点型到整型}

\begin{cpp}
int main() {
  std::vector<double> values;
  values.push_back(3.14); values.push_back(2.71); values.push_back(1.5);
  values.push_back(-1.5); values.push_back(-2.71);
  values.push_back(-3.14);
  std::cout << "value trunc floor round ceil\n";
  for (int i = 0; i < values.size(); ++i) {
    double v = values[i];
    std::cout << std::setw(5) << v
      << std::setw(6) << static_cast<int>(v)
      << std::setw(6) << std::floor(v)
      << std::setw(6) << round(v)
      << std::setw(5) << std::ceil(v)
      << '\n';
  }
  return 0;
}
\end{cpp}

上述代码的输出结果如下：

\begin{shell}
value trunc floor round ceil
 3.14     3     3     3    4
 2.71     2     2     3    3
  1.5     1     1     2    2
 -1.5    -1    -2    -2   -1
-2.71    -2    -3    -3   -2
-3.14    -3    -4    -3   -3
\end{shell}

回到分析部分中提到的问题，快速回顾一下就会发现选择适当的转换函数的好处，并且这样做无需添加其他逻辑。包装箱问题是存在非零小数部分的情况，需要一个完整的盒子，而不管小数部分的大小如何；正确的选择是使用天花板函数。账户问题，其中余额为− \$ 3.14，需要对账户(再次提款)中存入 4 美元以支付费用。此问题使用 floor 函数来提取正确的金额。

值得庆幸的是，银行和其他金融机构不使用浮点数来表示货币单位。他们从惨痛经历中了解到，当这种情况发生时，狡猾的开发人员可以“赚大钱”。这种技术就像切香肠一样，很容易掩盖——哪个金融机构愿意承认这样的内部欺诈行为？

需要更广泛的转换函数才能正确选择适当的转换方法，而无需确定边界条件并添加潜在的复杂逻辑。可以通过选择单个函数解决问题时，意图表达得更好(可读性)，并且更容易正确编码(有效性)。

\mySamllsection{建议}

\begin{itemize}
\item
理解要解决的问题，以及小数部分的含义。

\item
选择正确的函数将浮点值转换为整数。

\item
理解转换函数向负无穷、正无穷或零的移动方式。
\end{itemize}
