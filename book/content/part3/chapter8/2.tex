这个错误主要针对正确性、可读性和有效性。不必要的访问器打破了类和客户端代码之间的知识障碍。这些不必要的访问器需要花时间编写，但维护起来却很少；它们会带来额外的认知负担，而且几乎没有任何好处。

在面向对象编程的乐观时代，许多教科书和作者都提倡为每个私有实例变量提供访问器和修改器。流行的说法是，每个客户端都应该能够访问实例内的每个状态。这种代码淡化了更重要的方法，使阅读和记住类变得更加困难。遵循这一建议的代码充斥着返回实例变量值副本的访问器。这种方法打破了公共/私有封装障碍，并过度暴 露了实现细节。

\mySamllsection{问题}

这种方法在很多方面都存在语义问题。如果变量存在非必要访问器 ，则变量和类实现可能会危险地暴露给客户端。使用简单的访问器和修改器，公共变量和私有变量之间没有任何区别。泄露状态变量的实现细节表明客户端代码应该负责理解和管理它们。这个缺陷直接违反了维护类不变性的规定。修改类实现时，正确性和有效性会受到影响，因为客户端代码可能依赖于已公开的类的行为方式。

访问器的另一个不好的做法是使用实例变量来存储从其他实例变量派生的对象状态。假设有一个 Circle 类计算其面积，如清单 8.1 所示。一些遗留代码示例定义了一个名为 area 的浮点变量，该变量在构造函数中初始化。编写了一个简单的访问器来返回 area 实例变量的计算值。

\filename{清单8.1 带有计算值和简单访问器的类}

\begin{cpp}
class Circle {
private:
  const static double PI;
  double radius;
  double area;
public:
  Circle() : radius(1), area(PI) {}
  Circle(double radius) : radius(radius),
    area(radius*radius*PI) {} // 1
  double getArea() const { return area; } // 2
  double getRadius() const { return radius; }
};
const double Circle::PI = 3.1415927;

int main() {
  Circle c1(3);
  std::cout << c1.getArea() << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：计算的值，无论是否使用它们

注释2：一个简单的访问器，只允许访问计算值
}

非必需访问器会导致代码膨胀。实例由其构造函数初始化后，部分或大部分实例变量可能对客户端访问而言是不必要的。如上所述，这些访问器的一个后果是客户端可能依赖于变量的实现细节，从而阻止简单的重新实现。另一个结果是客户端可能承担理解和维护实例状态的责任。这种情况违反了类不变性，并将类知识传播到类外部的代码。

\mySamllsection{分析}

正确编写的类仅显示必要的状态信息，而不一定以类中使用的形式显示。它们的公共接口定义了客户端如何访问该信息，但没有定义该信息的实现方式、是缓存还是直接计算，或任何其他实现细节。客户端不得依赖实现细节，类编写者有责任防止这种情况发生。

Circle 类使用传入的半径信息构造一个实例。访问器为用户提供了 对 radius 值及其实现的无限制视图。area 方法依赖于预先计算的实例变量；其访问器仅返回该值。

应避免随意编写 radius 访问器；如果客户端需要此信息，则应提供。需要使用客户端代码验证该值以查看是否需要；如果是，则提供访问器。由于似乎只有圆的面积才有意义，因此计算该值很重要，而半径则不重要。但它确实存在，并且具有所有假定的优点。在添加半径访问器之前，应确定客户端要求。客户端已经提供了半径；如果它是必需的，客户端应该记住它。

第二个问题是面积的自动计算。在这种情况下，客户端可能需要这些信息，因此预先计算是一个好主意。但是，作为一种习惯，预先计算应该推迟到第一次（或每次）使用时。如果类更复杂，则不确定是否需要该面积。机器被称为 computer，因为它会进行计算 — 类设计者应该按照机器的意图工作并让它完成工作。

\mySamllsection{解决}

应将非必要的访问器作为一项政策删除。客户端可能需要这些值，但不应将其作为 assumed 来使用。扫描代码库可以揭示现有代码中是否使用了访问器。如果没有，则将其全部删除。如果使用了访问器，则确定客户端代码是否因使用它而超越了其职责。在示例代码中，如果客户端是需要绘制和排列圆形的图形程序，则半径将是必需的知识。如果客户端正在计算圆形铺路石的重量，则半径将无关紧要；只需计算面积。

\filename{清单8.2 带有计算访问器的类}

\begin{cpp}
class Circle {
private:
  const static double PI;
  double radius;
public:
  Circle() : radius(1) {}
  Circle(double radius) : radius(radius) {}
  double getArea() const { return radius*radius*PI; } // 1
};
const double Circle::PI = 3.1415927;
\end{cpp}

{\footnotesize
注释1：仅在需要时计算值
}

开发人员在编写计算访问器时必须采取平衡的方法，考虑计算成本。计算操作通常成本低廉，可按需计算。假设计算成本高昂（例如，使用大量数据、访问数据库或在线通信），则应尽可能少地计算其结果。在这种情况下，更好的方法是仅在第一次访问时计算结果，然后缓存结果。后续访问将快速访问缓存的值，从而减轻计算成本。

由于大多数访问器不会改变任何实例变量，因此最好将它们标记为const。编译器将强制承诺不会修改任何值；此外，这也是意图的良好文档。

\mySamllsection{建议}

\begin{itemize}
\item
不要编写访问器，除非可以证明它对于客户端使用必不可少；必不可少的访问器是必需的。

\item
不要维护可以计算其值的实例变量，除非这是计算量很大的操作。

\item
出于性能原因，应该缓存昂贵的计算结果。

\item
将访问器标记为 const 以传达其不变性。
\end{itemize}











