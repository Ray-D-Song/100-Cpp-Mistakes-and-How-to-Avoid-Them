这个错误关注的是正确性和有效性。多个构造函数通常作为单独的操作实现。此外，计算方法经常重复计算代码。这种重复应该导致考虑确定基准。并非所有重复都必须确定基准部分，但这是一个好兆头，表明可能找到。基准 是一个数学概念，定义了一组最小函数 - 所有函数都是必不可少的，并且没有重叠 - 可以从中实现其他非基础函数。don’t repeat yourself(DRY)原则与本次讨论相关，但必须服务于比通常呈现的更细微的目的 - 稍后会详细介绍。

实现多个构造函数或函数的差异，可能会导致错误的行为。在一个地方支持基本代码，可以节省开发者的时间。

本讨论分析了构造函数，但适用于方法和独立函数。主要想法是减少行为实现的数量，避免代码随着时间的推移而出现分歧。当功能重复并以不同方式维护时，事情很快就会出错。

通常，类会有多个构造函数，每个构造函数接受不同数量的参数。如果实例化调用中未提供某些信息，则需要提供默认值。在其他情况下，将应用默认行为来填补知识空白。

\mySamllsection{问题}

一个简单的例子可能有助于更好地理解基函数的含义。考虑一个包装内置 int 类型的 integer 类。这四种基本数学运算可能彼此之间有足够的差异，因此所有这四种运算都可以唯一地实现。然而，仔细分析表明事实并非如此。减法问题 a \verb|–| b 在数学上等同于 a + -b。减法可以用加法和反相来实现。因此，减法不需要是单独的运算。乘法是重复的加法，除法是重复的减法——或者重复加一个反相值。因此，只需要两个基函数来实现这四个算术函数——将两个整数值相加并对一个整数值取反。其他三个运算可以根据这两个进行定义。

这种操作以其他函数形式实现的思想，确立了如何区分基函数，并直接以这种方式实现。通过在尽可能少的地方编写计算代码，来确保正确性。以这些方式实现的其他方法将正常工作，并且不会重复可能在发生变化时变得不匹配的代码。通过为每个函数编写核心代码来保持有效性，并且通过在其他非基函数中反复使用来证明其正确性。

Cylinder 代码示例(清单 7.5)展示了一种典型的方法，即在未适当考虑基函数的情况下。其构造函数和操作是单独且独立地编码的。在类开发的早期，很容易假设代码在未来保持不变。很多情况下，这并不正确。通过添加一两个新要求，实现这些构造函数和函数可能会彼此分歧。任何分歧都会影响正确性、可读性和有效性。

\filename{清单7.5 类中重复的知识}

\begin{cpp}
class Cylinder {
private:
  double radius;
  double height;
  double area;
  double volume;
public:
  const double PI = 3.1415927;
  Cylinder() {
    radius = 1;
    height = 1;
    area = PI;
    volume = PI;
  }
  Cylinder(double h) {
    radius = 1;
    height = h;
    area = PI;
    volume = PI * h;
  }
  Cylinder(double r, double h) {
    radius = r;
    height = h;
    area = PI * r * r; // 1
    volume = PI * r * r * h; // 2
  }
  double getBaseArea() const { return area; }
  double getVolume() const { return volume; }
};
\end{cpp}

{\footnotesize
注释1：使用标准公式计算面积

注释2：体积等于面积*高度；再次计算面积
}

\mySamllsection{分析}

这些构造函数和函数的实现会重复知识，DRY 原则旨在防止这种情况。然而，DRY 通常实现为“不重复代码”方法，而不是更有帮助的“不重复知识”方法。随着时间的推移，功能类将容易受到新需求的影响，从而导致代码的添加和修改。这些变化是不可避免的，知识重复的可能性也会增加。当复制的知识在一个地方发生变化，而另一个地方没有变化时，就会发生分歧。一段时间后，就不清楚正确的版本是哪个了。

每个构造函数都会重复实例变量的初始化，有时使用默认值，有时使用参数。这种重复表明了一种更好的方法。代码展示了一种典型的模式，可以将其重构为单个辅助函数。辅助函数的好处是，所有构造函数都可以使用，并避免知识和代码的重复。当添加新需求时，更改会隔离到辅助函数中。

\mySamllsection{解决}

解决这个问题的最佳方法是，了解如何根据其他函数来实现函数，然后将该依赖关系缩小到最低限度。构造函数应该将标准代码分解出来，并将其放在私有辅助方法中。此辅助方法将成为根据辅助方法，实现的构造函数的基础。
getBaseArea 方法计算圆柱体圆形底面的面积。volume 方法计算圆柱体圆形底面的面积，然后将其乘以其高度。能否分解出通用代码，并进行单一面积计算决定了必要的基础，这时体积方法应根据 basearea 方法实现，而非辅助函数。

方法重用也发生在类继承中，其中派生类继承基类方法功能并对其进行添加。许多情况下，重写的派生类方法可以调用基类方法，作为其计算的一部分，并根据需要对其进行修改。这种方法可以防止功能重复，并允许派生类从基类中受益。设计得当的基类方法，应该是派生类基础的一部分。

这些重构步骤已在清单 7.6 中执行。已创建一个名为 init 的辅助方法，来处理构造函数中的先前重复。

volume 方法现在使用 basearea 来计算圆柱体的面积，并将该值乘以高度。体积以底面积的形式实现，以避免在变化发生时出现分歧。简单的情况下，知识重复可能不是问题。然而，这个问题可以扩展到更复杂的类，其中知识重复的影响更大。

\filename{清单7.6 函数的最小集合}

\begin{cpp}
class Cylinder {
private:
  double radius;
  double height;
  void init(double r, double h) {
    radius = r;
    height = h;
  }
public:
  const double PI = 3.1415927;
  Cylinder() { init(1, 1); }
  Cylinder(double h) { init(1, h); }
  Cylinder(double r, double h) { init(r, h); }
  double basearea() { return PI * radius * radius; } // 1
  double volume() { return basearea() * height; } // 2
};
\end{cpp}

{\footnotesize
注释1：计算面积

注释2：计算体积
}

\mySamllsection{建议}

\begin{itemize}
\item
将通用构造函数代码分解为辅助函数，该函数将成为类的基础集的一部分。

\item
考虑如何根据其他基础函数实现函数，以简化编码、避免发散，并为该知识维护真实来源。

\item
最小化基础函数集，确保功能不重叠。

\item
添加新函数时，以基础函数为基础，并重新评估是否需要新的基础函数。

\item
如果这种方法变得难以操作或过于笨拙，请放宽限制。请记住，原则有助于最大限度地减少技术债务，并加快开发速度，但盲目执行可能会导致更糟糕的后果。

\item
寻找机会将重叠的方法，重写为基础函数或集合。
\end{itemize}























