
很多时候，课程设计都是从一个相对纯粹的想法开始的，并且这个想法得到了很好的实现，但随后却面临着不可避免的变化。变化通常是因为类有效，但似乎不完整而需要。然后，需要进行额外的更改，设计受到损害，权宜之计胜过精确性，并且会发生混乱。类腐烂但仍然有用。代码异味(非理想技术或实现，通常是由于时间限制或对问题空间或代码影响的理解不足)不断增加，但时间和预算决定了其他优先事项。

检测这些问题通常比确定解决方案要简单。常见错误通常可以修复，对代码库的其他部分的影响很小，但这些错误仅代表现有问题的一小部分。关于类设计错误的内容可以写成一整本书。

良好的类设计是理解和维护类不变性的基础。类表示一种数据类型，必须保持一致性和正确性，实例才有意义。忽略不变性，会导致实例出现不一致和可能失败的情况。客户期望正确性，作为开发人员，我们有责任满足这一期望。

\mySubsubsection{7.2.1.}{类的不变量}

“类的不变量” 是类对象在构造之后，以及在该对象上的方法调用序列之间，必须始终满足的条件。其表示对象的一致、有效状态，通常通过构造函数、析构函数和成员函数强制执行。类不变量可确保对象数据的完整性和正确性。

每个类都应该代表一个概念或一个实体；类是一种新的数据类型。有意义地描述其概念或实体，聚合其他数据类型，从不同的类到原始类型。良好的设计和理解类不变量是同一枚硬币的两面。其抽象原则为：首先，类将概念或实体的细节减少到最低限度，用于定义类。其次，抽象表示整个实例可以作为一个单元来处理。这种实体或概念的抽象应该由用户代码有意义地表现。类应该避免以意想不到的表现，而让用户感到意外。

由于类表示概念或实体，所以必须将其内部数据限制为对其表示有意义的特定值。如前所述，Student 应该具有非负的 age。类是有关所表示实体或概念的知识的来源，不应依赖任何其他类或外部数据来传达。封装原则在某种程度上意味着，类所知道和所做的一切都应完全包含在类中。用户代码应该能够与实例交互或从实例获取任何必要的数据，而无需操作或查询其他对象或变量。

这些特征伴随着责任。类必须确保其所有数据成员(无论是单独还是整体)都是合法的，并且始终有意义，并且与它的交互可预测，不会出现意外。此外，它还必须确保在程序执行期间，这种敏感性和可预测性永远不会受到损害。这个类的责任称为 “类的不变量” 。不变量是实例的一个属性，它始终无论如何初始化或修改实例，都是 true。类绝不能创建不遵守不变量责任的实例，并且保护现有实例避免不变量的变化。

正确性特征对于程序的正确行为最为重要。如果程序代码不正确，则无法保证任何事情；无论多大的性能都无法弥补此错误，结果也是可疑的，保持类不变是确保正确性的重要手段。当类的行为受控且可预测时，用户可以放心地使用它，其结果也是有意义的。遗留代码中的类通常设计时，考虑了不变量以外的其他因素。存在大量机会来清理许多现有类，但修改(即使是使类更可预测和更强大的修改) 可能会导致意外行为。一如既往，理想和理论必须尊重现实。目标是改进，但道路可能有些(或非常)坎坷。

\mySubsubsection{7.2.2.}{建立类的不变量}

类表示一致、有凝聚力的概念或实体。类要求必须分别和总体指定每个实例变量的界限。总体表示实例的状态。一个重要的目标是确保实例的状态一致。继续使用 Person 的示例，如果 age 的值为负数，则Person 的含义将受到威胁——负数年龄代表什么？

建立类不变量是构造函数的工作；维护不变量是修改器或其他改变状态函数的责任。每个实例变量必须初始化并保持有意义且正确的值。实例的解释取决于是否维持不变量。变量类型的值范围可能会超出不变量的范围，因此构造函数和变量必须确保没有值超出范围。我观察到一些代码，这些代码使用访问器来验证范围，并仅返回有意义的值，从而将实例变量初始化或设置为无效值。如果实例变量表示无效值，则必须考虑违反类不变量。

本章中的错误主要集中在建立类不变性上，所以本章重点介绍构造函数。下一章将单独讨论修改器，修改器是维持类不变性所必需的。这两章截然不同，但必须协调一致，共同努力才能使类不变性保持正确。
