这个错误严重影响正确性，因为它是面向保持类不变的。可读性受到影响，因为阅读使用默认构造函数的代码无需额外检查便可知道初始化值为何。

确保对象的实例化保持类不变是构造函数的主要职责。许多类需要对实例变量进行特定的初始化，以使其处于有意义的状态。当未通过参数指定初始化值时，提供默认构造函数以向变量提供有效（但不一定有意义）的值。如果无法确定正确的默认值，则默认构造函数将实例 初始化为不一致的状态。假设类设计者希望开发人员稍后用有意义的值填充这些值。如果没有调用一个或多个变量器来满足这一期望，就会出现问题。

\mySamllsection{问题}

默认构造函数可能看起来更有效，但通常情况并非如此。默认值通常必须在稍后修改以添加有意义的数据，从而使有效性和可读性变得复杂。假设在使用实例之前更改初始化值，性能会略有影响。

实例的状态中不应包含无效或无意义的数据。如果使用默认构造函数，则必须将类设计为具有“典型”对象的有意义的默认值，这些默认值无需进一步修改即可使用。

清单 7.14 中的代码有些典型，但完全没有意义。由于没有给出程序员提供的默认构造函数，因此编译器提供了其默认版本，它将所有类实例初始化为其默认值。内置实例不是根本没有初始化。因此，name 将为空字符串（一个奇怪的名称），而age 将未定义（垃圾）。只有调用容易忘记的 setter 来提供有意义的值，才能实现对此类对象的有意义使用。如果没有验证，此类 setter 是危险的，因为无效值可能会被分配给实例变量。

\filename{清单7.14 默认构造函数，导致无意义的结果}

\begin{cpp}
class Person { // 1
private:
  std::string name; // 2
  int age; // 3
public:
  std::string getName() { return name; }
  int getAge() { return age; }
};
int main() {
  Person p1; // 4
  std::cout << p1.getName() << ' ' << p1.getAge() << '\n';
}
\end{cpp}

{\footnotesize
注释1：没有提供程序员编写的默认构造函数；因此，编译器会编写一个

注释2：类实例将调用其默认构造函数

注释3：内置实例将不会被初始化（它将包含垃圾）

注释4：将调用编译器编写的默认构造函数 — name 将被初始化，但 age 不会
}

添加显式的默认构造函数也并没有什么好处：

\begin{cpp}
Person() : name(""), age(0) {}
\end{cpp}

但是，age 实例变量将被初始化，从而防止未定义的行为。

\mySamllsection{分析}

任何业务问题都不可能出现没有姓名且年龄为零的人；但是，如果默认构造函数是必要的，则必须允许这种危险情况发生。默认值可以更 改为 Lakshmi 和 21，但这样一来，所有默认的人的名字都是Lakshmi，年龄都是 21。这种方法没有任何好处，更糟糕的是，它进一步掩盖了问题。

在这种情况下唯一有意义的构造函数是

\begin{cpp}
Person(const std::string& name, int age) : name(name), age(age) {}
\end{cpp}

这里，需要两个参数来创建一个 Person 对象；实例变量用这些值初始化，从而避免使用（可能）毫无意义的默认值，并消除无法调用变量器的问题。

类不变量要求每个数据成员都具有有意义的数据。默认构造函数经常违反这一原则。默认构造函数可能是对选择错误数据结构的道歉。

必须使用默认构造函数的最突出情况之一是创建对象数组时。在这种情况下创建数组，并通过调用默认构造函数初始化每个元素。除了极少数情况外，每个元素都会违反类不变量。

\mySamllsection{解决}

通常，在创建对象时初始化所有实例变量对于保持正确性至关重要。
在少数情况下，默认构造函数可能是一种合理的方法。由于元素的初始化数据尚未确定，因此必须调用默认构造函数来初始化实例变量。在某些情况下使用数组是有意义的，但会导致问题。代价是效率略有提高，而不是正确性。数组通常分配在堆栈上（除非使用 new 关键字创建）。此外，教科书隐含地教授数组，使它们在学生心中占据首要地位。当有选择时，先学到的东西通常会首先使用。由于这个问题，在几乎所有情况下，都应该首先教授向量，并且优先使用向量而不是数组。

向量使用一个间接层（指针）来访问数据；因此，数组在访问过程中会稍微快一些。但是，开发人员必须能够证明这种微小的增益对正确性的影响是合理的。数组是典型且经常使用的，但它们的缺点可能很大。更好的方法是选择一个不坚持默认构造的容器。

清单 7.15 展示了一个使用数组和可比较向量的简单示例。数组使用默认构造函数，导致混乱。向量需要为每个元素使用双参数构造函数，以保证正确（非默认）初始化；向量要求元素可复制。现代 C ++ 可以在创建数组时使用初始化列表来缓解默认构造函数，但前现代 C++ 就没有这样的运气了。

\filename{清单7.15 优先使用vector而不是数组}

\begin{cpp}
class Person {
  private:
  std::string name;
  int age;
public:
  Person() : name(""), age(0) {}
  Person(const std::string& name, int age) : name(name), age(age) {}
  std::string& getName() { return name; }
  int getAge() { return age; }
};

int main() {
  Person people[2]; ❶
  for (int i = 0; i < 2; ++i) ❷
    std::cout << people[i].getName() << " is " << people[i].getAge() << '\n';

    std::vector<Person> peeps;
  peeps.push_back(Person("Susan", 21));
  peeps.push_back(Person("Jason", 25)); ❸

  for (int i = 0; i < peeps.size(); ++i) ❹
    std::cout << peeps[i].getName() << " is " << peeps[i].getAge() << '\n';
}
\end{cpp}

{\footnotesize
注释1：调用默认构造函数，导致每个元素被错误地初始化

注释2：元素的数量可能会改变，但这个值可能会被忽略

注释3：向vector中添加任意数量的元素，并跟踪它们的数量

注释4：添加或删除元素后，此循环总能正常工作
}

\mySamllsection{建议}

\begin{itemize}
\item
不要仅仅因为默认构造函数很熟悉或很常见就添加它们，因为它们可能很危险。

\item
请仔细考虑是否要添加默认构造函数，记住，除非每个实例变量都正确初始化，否则对象是误导性的或无效的。

\item
优先使用向量或其他容器而不是数组，因为数组需要使用默认构造函数来初始化每个元素。

\item
记住类不变量和默认数据成员的含义——如果默认构造对象是有意义的，那么就这样做；如果没有，请避免使用默认构造函数。
\end{itemize}







