此错误主要针对类设计和开发中的正确性和有效性。实例变量必须初始化为类确定的边界内的值。这可确保对象在使用前定义明确且有效。

变量器会修改实例变量的状态。为了保持类不变性，它们必须确保检查输入参数的值是否在该变量的可接受范围内。此外，影响任何实例 变量状态的其他方法中的任何代码都必须确保它不会损害不变性。确保构造函数、变量器和支持代码维护类的不变性至关重要。

每个构造函数负责初始化所有实例变量。如果任何值是默认值，则该值通常必须有意义，并且如果默认值稍后未被修改，则不会导致实例 无效。每个变量必须确保其输入参数值在可接受值范围内，并且仅在这种情况下修改其实例变量。假设构造函数或变量的参数值无效。在这种情况下，类的行为必须确保实例的状态符合不变量。在许多情况下，无效参数输入应通过引发异常来处理；在其他情况下，不应修改实例变量。最后一种方法可能会导致构造函数出现问题。使用构建器 或工厂模式时可能会出现进一步的复杂情况。在所有情况下，实例变量在使用实例之前必须有效。

\mySamllsection{问题}

正确编码的构造函数或构造函数集将使用有意义的值初始化每个实例 变量，否则不允许实例化对象（即抛出异常）。保持类不变性需要满足这个条件，而且不能低于这个条件。每个变量都必须验证输入参数，并确保变量不会因无效值而更新，否则会抛出异常。影响实例变量 的所有其他方法都必须保持类不变性。当不遵守这些条件时，就会出现困难，如清单 7.1 所示。

许多类都有由编译器或开发人员编写的默认或无参数构造函数。假设开发人员没有为该类提供任何构造函数。在这种情况下，编译器将编写一个默认构造函数，其中每个实例变量在被调用时都将初始化为该类型的零值。该语句的条件部分表明是否调用默认构造函数取决于变量的定义或赋值方式。

\filename{清单7.1 典型的教科书结构}

\begin{cpp}
struct Person {
  int age;
  std::string name;
};

int main() {
  Person p1;
  std::cout << p1.age << " '" << p1.name << "'\n"; // 1
  Person p2 = Person();
  std::cout << p2.age << " '" << p2.name << "'\n"; // 2
}
\end{cpp}

{\footnotesize
注释1：age 会输出垃圾信息（未定义），name 打印空字符串

注释2：这将打印：0 ''
}

编译器提供了无参数构造函数，但在第一种情况下不会调用它。在第二种情况下，将调用提供的构造函数，这演示了将原始（或内置）变量初始化为该类型的零值的行为。在这两种情况下，实例都会调用其默认构造函数。

清单 7.1 中的代码的输出是不可预测的——对于 age 变量，这是未定义的行为。内存的每个字节都有一些值；输出是代表该变量的字节被解释为的任何值（即垃圾！）。这让我们对这段代码感到不确定。

\mySamllsection{分析}

由于构造函数的职责是初始化每个实例变量，因此使用第一种方法会导致其失败。如果构造函数失败，它就无法保持类不变。更糟糕的是，编译器从不抱怨；实例变量是内存中已有的未定义值，一切似乎都正常。如果使用这些值，将导致未定义的行为。如何调用编译器编写的默认构造函数取决于实例的设置方式。如果开发人员编写了默认构造函数，则无论哪种情况都会调用它。因此，如果需要保持类不变，开发人员必须编写默认构造函数。例如，这是一个可能的默认构造函数：

\begin{cpp}
Person() : name("Joey"), age(21) {}
\end{cpp}

但这是一个好的、有意义的默认构造函数吗？这个构造函数很容易编写，但需要回答一个好的默认名称和年龄的问题。在大多数情况下，默认构造函数会导致类不变量失败，因为实例是用无意义的数据初始化的——根据变量类型的约束，不是无效的，只是没有意义。虽然默认构造函数将名称 Joey 和年龄 21 分配给 Person 实例，但这有什么意义呢？客户端代码稍后可以将值更改为对其问题有意义的值，但如果忽略了一个实例的一个变量会发生什么？类不变量无法得到保证。

开发人员必须编写接受多于零个参数的构造函数。客户端代码可以创建一个 Person 实例并传递一个将姓名和年龄传入具有合理数据的双参数构造函数。

考虑 Person 结构的构造函数：

\begin{cpp}
Person(const std::string& n, int a) : name(n), age(a) {}
\end{cpp}

如果为该类编写了任何构造函数，编译器将不会提供默认构造函数。因此，如果还需要默认构造函数，开发人员必须明确包含它。请记住，如果不假设（或希望）客户以后会更改它们，那么获取适合问题的默认构造函数默认值是一项负担。如果无法做到这一点，默认构造函数将违反约束。

如果不小心，变量器也可能违反类不变量。考虑以下 age 实例变量 的变量器：

\begin{cpp}
void setAge(int a) { age = a; }
\end{cpp}

年龄可以设置为负值或不合理的大值，这两种情况都没有意义。将下限限制为非负值可以解决值范围的一端问题，但要真正解决上限问题却很有挑战性。什么值才是最有意义的最大年龄？

\mySamllsection{解决}

理想情况下，构造函数和修改器以协调的方式工作。构造函数有责任建立类不变量，但不一定直接初始化每个实例变量。如果构造函数和修改器都初始化或修改同一个实例变量，它们很可能重复知识。这些知识应该封装在变量中。构造函数可以调用每个变量，传递其初始化参数值。变量验证参数值并进行适当处理。构造函数必须确保调用变量来执行初始化，而不一定初始化实例变量。

在这种情况下，开发人员或编译器提供的默认构造函数将无效 — 无法为 name 或 age 变量默认有意义的正确值。尽管使用默认构造函数可能很诱人，但请尽可能避免使用它们，方法是编写至少一个需要每个实例变量参数的构造函数。

请注意，使用数组时没有默认构造函数会产生负面影响。定义类实例 数组意味着必须调用默认构造函数来初始化每个元素；在这种情况下，没有默认构造函数是一种错误。请参阅“另请参阅”部分以了解更 多讨论。

清单 7.2 演示了构造函数和变量器协同工作以使用部分年龄范围检查来初始化实例。需要注意的是，在这个略显复杂的代码中，age 被设置了两次，但它旨在演示限制允许的值范围——教师可以做这样的事情！将范围检查代码移动到私有验证函数并在初始化程序和 setAge 函数中调用它是一种更好的方法。

\filename{清单7.2 要求每个实例变量的初始化值}

\begin{cpp}
struct Person {
  int age;
  std::string name;
  Person(std::string n, int a) : name(n),
    age(setAge(a)) {} // 1
  int setAge(int);
};

int Person::setAge(int a) {
  if (a < 0)
    throw std::out_of_range("age must be non-negative");
  age = a;
  return age;
}

int main() {
  Person annie("Annette", 25);
  Person floyd("Floyd", -1); // 2
}
\end{cpp}

{\footnotesize
注释1：在构造期间调用成员函数的技术可能会产生未定义的行为。保持简单或选择其他方法

注释2：引发 out\_of\_range 异常
}

当函数或构造函数无法有意义地执行其应执行的操作时，最好的解决方案是抛出异常。此方法不同于返回错误返回代码。错误返回代码意味着由于某些错误条件而无法执行某些操作，但对象或函数仍处于良好状态。对于构造函数，不能使用无效值来初始化实例变量。如果没有合理的默认值可用，则不能实例化该对象，因为无法初始化该变量 。因此，最好抛出异常。异常会强制调用者处理不存在对象的可能性。返回不正确的返回代码意味着已实例化该对象并保持类不变量。对于无效数据，两者都无效。

\begin{myNotic}{NOTE}
本书中的几个解决方案都使用了在初始化列表中调用成员函数的方法。在某些情况下，这可能会产生未定义的行为。请参阅 \url{https://compiler-explorer.com/z/PPes7vPYd} 以获取有意义的示例。我将它们用于简单变量。如果该方法依赖于任何其他变量的状态，事情可能会很快变得一团糟；因此，请谨慎使用此技术。
\end{myNotic}

\mySamllsection{建议}

\begin{itemize}
\item
确保构造函数正确初始化每个实例变量。

\item
如果可用，构造函数应调用实例变量赋值器进行初始化，以防止代码重复。

\item
赋值器应在将值分配给实例变量之前验证输入参数值；如果值不正确，则抛出异常。

\item
如果无法完全正确地初始化实例，则抛出异常——不要创建部分或错误构造的对象。

\item
在大多数情况下避免使用默认构造函数；如果需要，请自己编写。
\end{itemize}
