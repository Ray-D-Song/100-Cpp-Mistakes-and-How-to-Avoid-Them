资源管理影响的主要特征是正确性。不正确的行为会影响程序，并且可能对程序本身（例如系统）产生不利影响。大多数其他正确性问题的范围有限 — 这种错误可能无处不在，影响其他程序和系统。

这三大函数——复制构造函数、复制赋值运算符和析构函数——在 C ++ 的每个版本中都可用，并且在使用动态资源时应始终进行编码。缺少其中一个或多个可能会对程序产生不利影响。

许多类都有一个或多个基于值的实例变量。示例包括整数或双精度数来表示数值。有些使用 std::string 或 std::vector。这些变量在实例化时初始化，在程序执行期间使用一段时间，然后在实例被删除时被删除。

超出范围。这些变量是自动管理的，不会给开发人员带来不利影响。

但是，那些更复杂的类使用动态或有限的资源，并使用变量来表示它们。一个典型的例子是基于指针的变量。这些变量通常表示动态内存资源。同样，有限资源通常由基于值的变量表示。在这种情况下，资源表示必须妥善管理的某些有限系统资源的实例。这可能包括数据库连接、套接字或文件句柄。虽然当实例超出范围时会自动管理实例变量，但引用的资源不会自动管理。这种管理缺失为不正确的行为提供了很大的机会。程序员必须在这些情况下保持警惕并正确管理资源。

\mySamllsection{问题}

当一个类具有动态资源时，它必须正确地管理这些资源。将它们的管理视为类不变量的一部分。该类承诺在其操作中建立、管理和删除资源。动态内存的示例显示了正确的分配和释放步骤。

某些客户端代码调用构造函数。构造函数中发生 new 操作以获取动态内存，从而建立部分不变量。其他实例方法使用此内存，保持不变量完好无损。最后，当实例超出范围（或被明确删除）时，将调用其析构函数以 delete 内存。如果此方法正确执行，则不会出现内存泄漏，也不会出现双重释放不会出现释放无效指针的情况，保证了程序和系统的稳定性。

另一个问题出现在与构造函数和析构函数操作无关的动态资源上。复制赋值运算符存在影响正确性的问题，必须仔细考虑。让我们在这里 区分 copy constructor 和 copy assignment operator。在创建实例时获取原始内存块时会调用构造函数。此原始内存可以容纳任何东西； 其状态未定义。构造函数必须使用有意义的数据初始化原始内存，以建立类不变量。

另一方面，复制赋值运算符不会初始化实例；它会使用来自另一个已初始化实例的值来改变现有实例。必须小心确保复制赋值运算符处理 自赋值（它应该只是返回）。复制构造函数必须获取新的动态资源并初始化其指针或相对于该值的句柄变量。复制赋值运算符必须执行相同的操作，但要多加一步。如果复制赋值运算符的目标已经具有动态资源，则在许多情况下必须将其销毁以防止内存或资源泄漏。在某些情况下，可以复制源实例值，但在许多其他情况下需要修改此方法。

复制构造函数和复制赋值运算符中的许多代码将被重复。有机会将此代码重构为两者都可以调用的私有辅助函数。必须考虑调用析构函数的影响，以确保任何重复的销毁代码得到正确处理。RAII 模式演示了这种成对的分配和释放。

假设已经编写了一个用于操作 wiki 页面的项目。负责该项目的公司要求每个页面都有一组特定的标题。提出了一个新要求，即开发一个复制操作来克隆一个页面作为新页面的基础。复制构造函数是此操作的理想选择。

添加此复制构造函数代码是为了包含新的复制功能。不幸的是，开发人员忘记添加复制赋值运算符代码。

\filename{清单7.7 共享唯一资源的复制构造函数}

\begin{cpp}
class TextSection {
  // assume a clever implementation
};

class Page {
private:
  TextSection* headers; // 1
  TextSection* body;
public:
  Page(TextSection* h) : headers(h), body(new TextSection()) {}
  Page(const Page& o) : headers(o.headers), body(o.body) {} // 2
  Page& operator=(const Page&);
};

int main() {
  Page p1(new TextSection());
  Page p2 = p1;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：动态资源

注释2：复制动态资源指针；两个对象使用一个动态资源
}

\mySamllsection{分析}

开发人员需要解决复制构造函数使用共享语义这一事实。标头可以共享，因为它们是公司规定的，不可更改。共享的正文是一个问题。作为正常操作的一部分，克隆的页面将对其正文进行更改。由于它是共享的，这将影响复制自的页面。此外，当 Page 因超出范围而被销毁时，堆内存中的正文 TextSection 将被隔离且无法访问，从而导致内存泄漏。

正确的复制构造函数必须考虑到指针的浅拷贝会实现共享语义，这对于页面主体来说是不可取的。克隆的页面必须分配一个从复制自页面初始化的新 TextSection。由于主体文本是由指针处理的动态资源，因此析构函数必须确保当实例超出范围时，在销毁实例之前删除动态资源。添加析构函数可确保实现正确的销毁。最后，由于已添加复制构造函数和析构函数，因此确保也添加复制赋值运算符至关重要。

复制构造函数假定新实例使用原始内存（填充了垃圾值）。复制赋值运算符假定受影响的实例已正确构造，并且每个实例变量都具有合法值。Page 类显示将源主体指针复制到目标（浅表复制）会导致设计不 良的复制构造函数中演示的错误。复制赋值运算符必须确保对动态资源使用深度复制语义。它还必须确保在深度复制发生之前正确删除或以其他方式处理任何现有动态资源。复制赋值运算符必须在创建新主体之前添加代码以删除现有主体。

\mySamllsection{解决}

清单 7.8 展示了这些改进。复制构造函数假设没有现有的动态资源，因此它分配一个新的 TextSection 对象。类似地，复制赋值运算符执行相同的分配，但首先通过删除现有资源来处理它们。最后，析构函数确保删除所有动态资源。

三大系统之间的资源协调可以防止资源泄漏（通常以内存泄漏的形式出现）。它保留了特定对象的唯一性，确保了程序运行的正确性。

\filename{清单7.8 保持唯一性的复制构造函数}

\begin{cpp}
class TextSection {
  // assume a clever implementation
};

class Page {
private:
  TextSection* headers;
  TextSection* body;
// 1
public:
  Page(TextSection* h) : headers(h), body(new TextSection()) {}
  Page(const Page& o) : headers(o.headers), body(new TextSection(*(o.body))) {}
// 2
  Page& operator=(const Page&);
  ~Page() { delete body; }
};
Page& Page::operator=(const Page& o) {
  if (this == &o)
    return *this;
  headers = o.headers;
  delete body;
  body = new TextSection(*(o.body));
  return *this;
}

int main() {
  Page p1(new TextSection());
  Page p2 = p1;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：动态资源

注释2：从现有副本创建并初始化新的动态资源
}

现代 C++ 将措辞从 big 3 更改为 big 5。另外两个成员是移动构造函数和移动赋值运算符。对三大函数的建议保持不变，但增加了额外的移动语义。清单 7.9 显示了清单 7.8 中的代码，使用现代移动语义和智能指针进行了改进。注意 =default 的使用。

\filename{清单7.9添加唯一性保护、move构造和赋值}

\begin{cpp}
class TextSection {
  // assume a clever implementation
};
class Page {
private:
  TextSection* headers;
  std::unique_ptr<TextSection> body;
public:
  Page(TextSection* h) : headers(h),
  body(std::make_unique<TextSection>()) {}
  Page(const Page& o) : headers(o.headers),
  body(std::make_unique<TextSection>(*o.body)) {}
  Page& operator=(const Page& o) {
    headers = o.headers;
    body = std::make_unique<TextSection>(*o.body);
    return *this;
  }
  Page(Page&&) = default; // 1
  Page &operator=(Page&&) = default; // 2
};

int main() {
  Page p1(new TextSection());
  Page p2 = p1;
  return 0;
}
\end{cpp}

{\footnotesize
注释1：现代的移动构造函数

注释2：现代的移动赋值运算符
}

\mySamllsection{建议}

\begin{itemize}
\item
如果在类中使用了任何动态资源，请务必编写三大要素：析构函数、复制构造函数和复制赋值运算符。

\item
请记住，构造函数用于初始化原始内存，而赋值运算符用于更新现有的、已构造的实例。务必妥善处理现有资源。

\item
确保移出的对象被中和，以便在正确初始化之前无法重用它们。
\end{itemize}


















