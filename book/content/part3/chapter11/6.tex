此错误主要影响性能，并且会影响可读性。C++ 允许通过值、指针或引用传递参数。正确选择至关重要。正确使用参数的三个方面是其大小、用法和安全性。以下讨论将重点讨论 std::string 参数，偶尔会引用内置类型。

参数的大小取决于其数据类型。值参数作为来自调用站点的参数值的副本传递。内置类型往往很小，将其作为副本传递通常很有效，但用户编写的数据类型可能很大。std::string 对象的大小取决于运行时库；可能存在各种大小，但将假定大小为 32 字节。如果字符串通过值传递，则堆栈必须为副本分配 32 个字节，并执行代码以将这些字节从源复制到堆栈。这项工作会影响性能和调用堆栈上的可用空间。

如果使用指针传递参数，则堆栈必须为架构的指针大小分配足够的字节——为了便于讨论，假设为 8 个字节。就大小和速度而言，通过指针传递字符串可能比通过值传递更高效——与大多数性能声明一样，测量对于验证至关重要。

最后，如果参数通过引用传递，代码的作用就如同通过指针传递的参数。传递的数据大小为 8 个字节。引用语法与指针语法不同，但更易于使用。

因此，按值传递值的大小变化最大。如果数据类型较小，8 个字节或更少(在 64 位架构上)，则按值传递的成本与按指针或引用传递的成本完全相同。但如果数据类型的大小超过 8 个字节，或具有非平凡的复制构造函数，则会产生额外的开销。

参数的用法就是其语义，确定如何使用参数对于正确传递至关重要。假设参数是一个输入值；任何传递方式都可以。应考虑可读性和性能来确定最佳方法；但如果要将参数用于函数的输出，则不能使用按值传递。必须通过指针或引用传递参数。另一种错误试图阻止人们使用输出参数。

通过指针或引用传递参数不仅限于简单的输出参数；否则，无法用于修改调用方范围内的源数据。如果调用方希望对数据容器进行排序，则向其传递指针或引用是最佳选择，可以避免复制容器的内容。在选择使用哪种传递类型时，必须彻底了解参数的用途。

最后，数据的安全性至关重要。由于指针或引用参数通常比值参数更有效，因此很容易假设所有参数都应该是这种类型。在接受这种效率之前，请仔细考虑可读性。这很关键，确定函数是否应该修改数据。如果函数不应该更改源数据，则必须适当使用 const 关键字。考虑到引用的易用性(以及可以修改调用方数据的函数)，在引用上使用 const 非常自由。由于指针语法更难编写和读取，因此引用是首选。此外，引用不能为空，不需要测试有效性。

\mySamllsection{问题}

通过值传递字符串比通过指针或引用传递字符串占用更多的空间。优点是参数是源数据的副本，函数无法修改该数据。引用的优点是语法简单。指针的一个优点是它熟悉旧代码库。指针的另一个优点是，在用于修改值时不会出错；引用看起来就像值修改，很容易忽略正在更新的内容。以下代码使用了每种可能性，而没有考虑何时应使用每种参数类型。

\filename{清单11.9 参数类型使用不当}

\begin{cpp}
const std::string catenate(std::string a, std::string& b, std::string* c) {
  std::string combined(a);
  b[0] = '-'; // 1
  combined += b;
  c[0] = 'z'; // 2
  combined += *c;
  return combined;
}

int main() {
  std::string msg1 = "Hello";
  std::string msg2 = ", ";
  std::string msg3 = "world!";
  std::cout << catenate(msg1, msg2, &msg3) << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：无意的拼写错误影响了原始数据；语法上没问题，但存在错误

注释2：另一个无意的拼写错误影响了原始数据；可以编译，但有缺陷
}

\mySamllsection{分析}

第一个参数效率低下；传递消耗超过指针大小的数据类型时应仔细考虑。

此外，必须将复制的构造函数和析构函数计入使用此方法的成本中。无论其易用性和对调用方数据的内置安全性如何，按值传递仅应用于较小的数据和内置类型。第二个参数高效但不安全，并且无法区分其用途是仅用于输入还是包含输出方面。第三个参数与第二个参数非常相似，而且增加了使用指针语法的复杂性。虽然这种语法可能很熟悉，但使用时可能需要费很大力气才能确定其确切含义。开发人员应考虑函数参数列表中每一项的大小、用法和安全性的影响。

\mySamllsection{解决}

清单 11.10 考虑了这三个特征，并为每个参数使用了最有意义的方法。由于字符串参数仅是输入，每个参数都将它们指定为 const 引用。现在显然不允许其修改调用者的数据，从而消除了作为输出参数的可能性。使用引用将最少量的数据从调用点传递到函数，从而对性能产生了积极影响。最后，当编译器强制执行其 const 性时，会阻止试图通过引用修改调用者数据的无意拼写错误。

\filename{清单11.10 正确使用参数类型}

\begin{cpp}
const std::string catenate(const std::string& a, const std::string& b, const
std::string& c) {
  std::string combined(a);
  // b[0] = '-'; // 1
  combined += b;
  // c[0] = 'z';
  combined += c; // 1
  return combined;
}

int main() {
  std::string msg1 = "Hello";
  std::string msg2 = ", ";
  std::string msg3 = "world!";
  std::cout << catenate(msg1, msg2, msg3) << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：现在这是一个错误；参数是 const，消除了无意修改的可能性
}

\mySamllsection{建议}

\begin{itemize}
\item
从大小方面考虑传递参数的效率。从调用点复制到函数的字节数是一般经验法则；如有疑问，请进行测试。

\item
考虑参数的用途；是仅输入、输入/输出还是仅输出；以及函数是否应修改调用方的数据。

\item
考虑数据的安全性 — 仅在明确需要时才允许修改调用方的数据；否则，请指定 const。
\end{itemize}









