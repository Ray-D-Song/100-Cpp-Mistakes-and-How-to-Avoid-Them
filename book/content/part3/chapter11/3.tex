这个错误影响了有效性和正确性。开发程序有两个时段——编译时和运行时，软件构建也有两个时段——开发时和生产时。这个错误主要针对软件的构建开发时。

\mySamllsection{问题}

程序开发过程中，会测试新想法、引入新代码，并尝试增加组件之间的交互。所有这些新事物都为漏洞的生长提供了完美的条件 —— 漏洞确实会滋生。

确保代码按预期运行，应该通过单元测试和集成测试来确认。在此之前，确保满足函数先决条件必不可少。此外，对于开发人员来说，确保满足函数后置条件和不变量也至关重要。然而，编写代码来测试和处理这些领域似乎总是⋯⋯可以推迟——明日复明日。

推迟先决条件、后置条件和不变量很诱人，但也很危险。如果没有足够的测试，错误就会悄悄出现并不断增加。以下代码就是一个例子；虽然它看起来无害，但其中却隐藏着真实而现实的危险。

\filename{清单11.3 意外的除零问题}

\begin{cpp}
// a divides b evenly
bool divides(int a, int b) {
  return b % a == 0; // 1
}

int main() {
  int x = 0;
  int y = 42;
  if (divides(x, y))
    std::cout << x << " divides " << y << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：这很少会出现问题，但是⋯⋯
}

大多数情况下，此代码都会正常运行，开发人员对其好处的信心也会增强。有一天，当编写此代码与关注其他较新的代码之间相隔很远时，此代码就会崩溃。但为什么呢？以前总是能正常工作。

\mySamllsection{分析}

原因是除以零的问题，错误的输入数据会导致问题浮现。这个错误一直存在，但从未暴露出来。单元测试应该能揭示这一点，但工作量是推迟编写验证代码的另一个“原因”。

\mySamllsection{解决}

开发过程中，发现错误的最佳方法之一是，编写前置条件和后置条件断言。这些小测试非常残酷 — 如果失败，程序会立即崩溃。从好的方面来说，错误暴露了，并且无需展开堆栈，调试器就可以在问题的确切区域设置一个。

断言是一个简单的测试，用于检查某事是否为真。编写起来很快，不需要特殊逻辑，而且功能强大。

下列代码快速解决了清单 11.3 中的潜在错误。

\filename{清单11.4 使用断言检查先决条件}

\begin{cpp}
// disable assertions by defining NDEBUG // 1
// a divides b evenly
bool divides(int a, int b) {
  assert(a!=0); // 2
  return b % a == 0;
}
int main() {
  int x = 0;
  int y = 42;
  if (divides(x, y))
    std::cout << x << " divides " << y << '\n';
  return 0;
}
\end{cpp}

{\footnotesize
注释1：向编译器传递 NDEBUG 标志，以禁用生产代码中的断言

注释2：证明除数非零
}

如果生产代码不应包含断言，请不要使用条件编译来删除它们。编译代码时向编译器定义 NDEBUG 宏，相关代码将消失 — 不存在运行时成本。

使用测试框架、工具和方法咨询其他软件工程和开发资源。这些远远超出了这个错误的范围，但这可以激发人们对其的研究和使用的兴趣。断言在调试期间特别有用，因此要学会很好地使用。

\mySamllsection{建议}

\begin{itemize}
\item
不要将先决条件、后置条件和不变性检查推迟到以后。在开发过程中使用断言来验证条件。

\item
使用单元测试框架进一步验证代码。不要将测试视为无功能的代码；相反，应将其视为证明其正确性的元代码。

\item
永远不要编写具有副作用的断言；如果禁用断言，代码的行为将发生意外变化。
\end{itemize}









